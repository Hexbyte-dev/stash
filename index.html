<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="theme-color" content="#6B5F53" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Stash" />
  <meta name="description" content="Capture and organize the things worth holding onto" />
  <title>Stash</title>
  <link rel="manifest" href="/manifest.json" />
  <link rel="icon" type="image/png" sizes="192x192" href="/icon-192.png" />
  <link rel="apple-touch-icon" href="/icon-192.png" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, sans-serif; background: #FAF7F2; }
    #root { min-height: 100vh; }
    /* Prevent pull-to-refresh on mobile when in standalone mode */
    body { overscroll-behavior-y: contain; }
    /* Safe area for notched phones */
    body { padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); }
  </style>

  <!-- React from CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script>
    // ============================================================
    // STORAGE SHIM
    // 
    // The artifact version of Stash uses window.storage (Claude's
    // persistent storage API). For a standalone PWA, we replace it
    // with localStorage — same interface, browser-native storage.
    //
    // localStorage is synchronous and stores strings, so we wrap
    // it in async functions to match the original API shape.
    // ============================================================
    window.storage = {
      async get(key) {
        const value = localStorage.getItem(key);
        if (value === null) throw new Error("Key not found: " + key);
        return { key, value };
      },
      async set(key, value) {
        localStorage.setItem(key, value);
        return { key, value };
      },
      async delete(key) {
        localStorage.removeItem(key);
        return { key, deleted: true };
      },
      async list(prefix) {
        const keys = [];
        for (let i = 0; i < localStorage.length; i++) {
          const k = localStorage.key(i);
          if (!prefix || k.startsWith(prefix)) keys.push(k);
        }
        return { keys };
      }
    };

    // ============================================================
    // SERVICE WORKER REGISTRATION
    // ============================================================
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker
          .register("/sw.js")
          .then((reg) => console.log("[PWA] Service worker registered:", reg.scope))
          .catch((err) => console.log("[PWA] Service worker registration failed:", err));
      });
    }

    // ============================================================
    // INSTALL PROMPT HANDLER
    //
    // Browsers fire a "beforeinstallprompt" event when the PWA
    // criteria are met. We capture it so we can show our own
    // install button instead of relying on the browser's banner.
    // ============================================================
    let deferredPrompt = null;
    window.addEventListener("beforeinstallprompt", (e) => {
      e.preventDefault();
      deferredPrompt = e;
      // Dispatch a custom event so our React app can show an install button
      window.dispatchEvent(new CustomEvent("pwa-installable"));
    });

    window.addEventListener("appinstalled", () => {
      deferredPrompt = null;
      window.dispatchEvent(new CustomEvent("pwa-installed"));
      console.log("[PWA] App installed successfully");
    });
  </script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

/*
  STASH — Your Personal Memory Bank
  v0.8: Business Card OCR + Pin Items + Export Data
  
  NEW CONCEPTS:
  - "OCR" (Optical Character Recognition) = extracting text from images
    We use the Anthropic API to analyze business card photos and pull out
    structured info like name, phone, email, company, title.
  - "Pinning" = flagging items as important so they always appear at top
  - "Data export" = converting app data to a downloadable JSON file
    This teaches you about Blob URLs and programmatic downloads
*/

const generateId = () => Date.now().toString(36) + Math.random().toString(36).slice(2);

// ============================================================
// TIMEZONE & DATE FORMATTING
// 
// NEW CONCEPT: "Timezones"
// Dates in JavaScript are stored as UTC (universal time).
// When we display them, we convert to a specific timezone.
// The Intl.DateTimeFormat API handles this — we just tell it
// which timezone to use (like "America/New_York") and it
// does all the math for daylight savings, offsets, etc.
//
// We use 24-hour time (aka "military time") — so 2:30 PM
// displays as 14:30. No AM/PM ambiguity!
// ============================================================
const timezoneOptions = [
  { value: "America/New_York",    label: "Eastern (ET)" },
  { value: "America/Chicago",     label: "Central (CT)" },
  { value: "America/Denver",      label: "Mountain (MT)" },
  { value: "America/Los_Angeles", label: "Pacific (PT)" },
  { value: "UTC",                 label: "UTC" },
];

const formatDateTime = (dateString, timezone = "America/New_York") => {
  const date = new Date(dateString);
  
  // Format the date portion: "Feb 24, 2026"
  const datePart = new Intl.DateTimeFormat("en-US", {
    timeZone: timezone,
    month: "short",
    day: "numeric",
    year: "numeric",
  }).format(date);

  // Format the time in 24-hour: "14:30"
  const timePart = new Intl.DateTimeFormat("en-US", {
    timeZone: timezone,
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  }).format(date);

  return `${datePart} · ${timePart}`;
};

// ============================================================
// AUTO-DETECTION
// Scans text for keywords to guess the category.
// Custom categories use user-defined keywords (stored in settings).
// The "auto" override skips this and uses whatever the user picks.
// ============================================================
const builtInKeywords = {
  link:    { pattern: /https?:\/\// },
  contact: { pattern: /(@.+\.\w{2,}|\d{3}[\s.-]?\d{3}[\s.-]?\d{4})/ },
  travel:  { pattern: /travel|flight|hotel|airport|trip|vacation|passport|airbnb|booking|destination|luggage|itinerary/i },
  work:    { pattern: /meeting|deadline|project|client|office|presentation|agenda|boss|colleague|report|quarterly/i },
  money:   { pattern: /price|\$|cost|budget|invest|expense|deal|sale|payment|invoice|subscription/i },
  health:  { pattern: /doctor|appointment|medicine|symptom|prescription|therapy|dentist|hospital|workout|vitamin/i },
  media:   { pattern: /song|album|playlist|podcast|movie|show|watch|listen|series|episode|spotify|netflix/i },
  event:   { pattern: /event|party|birthday|conference|concert|wedding|rsvp|invite|festival|ceremony|reunion/i },
  reading: { pattern: /read|book|article|blog|chapter|author|novel|paper|journal/i },
  food:    { pattern: /restaurant|eat|food|dinner|lunch|cafe|recipe|cook|brunch|bakery|reservation/i },
  idea:    { pattern: /idea|thought|maybe|what if|brainstorm|concept|possibility/i },
  person:  { pattern: /meet|person|name|card|introduce/i },
  recommended: { pattern: /recommend|suggested|check out|you should try|told me about|referred/i },
};

const detectType = (text, customCategories = []) => {
  // Check built-in patterns (link and contact first — most specific)
  for (const key of ["link", "contact"]) {
    if (builtInKeywords[key].pattern.test(text)) return key;
  }
  
  // Check custom categories (user-defined keywords take priority)
  for (const cat of customCategories) {
    if (cat.keywords && cat.keywords.length > 0) {
      const pattern = new RegExp(cat.keywords.join("|"), "i");
      if (pattern.test(text)) return cat.id;
    }
  }
  
  // Check remaining built-in patterns
  for (const key of Object.keys(builtInKeywords)) {
    if (key === "link" || key === "contact") continue;
    if (builtInKeywords[key].pattern.test(text)) return key;
  }
  
  return "note";
};

// ============================================================
// THEME SYSTEM
// 
// Instead of scattering color values everywhere, we define them
// in one place per theme. Every component references these.
// To add a new theme later, just add another object here!
// ============================================================
const themes = {
  light: {
    // Backgrounds
    pageBg: "#FAF7F2",
    cardBg: "#FFFFFF",
    inputBg: "#FFFFFF",
    searchBg: "#FFFFFF",
    settingsBg: "#FFFFFF",
    overlayBg: "rgba(250, 247, 242, 0.92)",
    hoverBg: "#F9F6F2",
    completedBg: "#F7F4EF",
    // Borders
    border: "#EDE8E0",
    borderHover: "#D5CEC4",
    // Text
    textPrimary: "#5C5347",
    textSecondary: "#8A7E72",
    textMuted: "#8A8278",      // timestamps, secondary labels
    textFaint: "#9A928A",      // placeholders, tips
    textGhost: "#A49C92",      // filter labels, faintest UI text
    // Accents
    accent: "#6B5F53",
    accentGradient: "linear-gradient(145deg, #8A7E72, #6B5F53)",
    disabledBg: "#EDE8E0",
    disabledText: "#9A928A",
    checkColor: "#7EB5A0",
    checkBg: "#EEF7F3",
    deleteColor: "#C48B8B",
    deleteBg: "#FAF0F0",
    // Shadows
    shadowLight: "0 1px 3px rgba(140, 120, 100, 0.04)",
    shadowMedium: "0 2px 12px rgba(140, 120, 100, 0.05)",
    shadowHover: "0 4px 20px rgba(140, 120, 100, 0.08)",
    shadowImage: "0 12px 48px rgba(120, 100, 80, 0.15)",
    // Category colors
    types: {
      note:    { color: "#9B8E7E", bg: "#F5F0EA" },
      link:    { color: "#7E9BB5", bg: "#EDF3F8" },
      contact: { color: "#C49A6C", bg: "#FAF2E8" },
      reading: { color: "#9B8BB5", bg: "#F3EFF8" },
      food:    { color: "#C48B8B", bg: "#FAF0F0" },
      idea:    { color: "#7EB5A0", bg: "#EEF7F3" },
      person:  { color: "#C49A6C", bg: "#FAF2E8" },
      photo:   { color: "#B5A67E", bg: "#F7F3EA" },
      travel:  { color: "#5E9EBF", bg: "#EBF4F8" },
      work:    { color: "#8A8EB5", bg: "#EEEFF8" },
      money:   { color: "#8AB57E", bg: "#EEF5EB" },
      health:  { color: "#B57EA0", bg: "#F5EBF2" },
      media:   { color: "#BF8A5E", bg: "#F8F0EB" },
      event:   { color: "#B5A05E", bg: "#F5F2E8" },
      recommended: { color: "#D4A05E", bg: "#FBF3E8" },
    },
  },
  dark: {
    // Backgrounds — rich, warm darks (not cold blue-black)
    pageBg: "#1C1A17",
    cardBg: "#262320",
    inputBg: "#262320",
    searchBg: "#222019",
    settingsBg: "#262320",
    overlayBg: "rgba(28, 26, 23, 0.94)",
    hoverBg: "#2E2B27",
    completedBg: "#21201C",
    // Borders
    border: "#3A3530",
    borderHover: "#4A443D",
    // Text
    textPrimary: "#D4CFC8",
    textSecondary: "#A89E94",
    textMuted: "#A09890",      // timestamps, secondary labels
    textFaint: "#8A827A",      // placeholders, tips
    textGhost: "#787068",      // filter labels, faintest UI text
    // Accents
    accent: "#D4CFC8",
    accentGradient: "linear-gradient(145deg, #A89E94, #7E756B)",
    disabledBg: "#3A3530",
    disabledText: "#8A827A",
    checkColor: "#7EB5A0",
    checkBg: "#1E2E28",
    deleteColor: "#C48B8B",
    deleteBg: "#2E2222",
    // Shadows
    shadowLight: "0 1px 3px rgba(0, 0, 0, 0.12)",
    shadowMedium: "0 2px 12px rgba(0, 0, 0, 0.15)",
    shadowHover: "0 4px 20px rgba(0, 0, 0, 0.2)",
    shadowImage: "0 12px 48px rgba(0, 0, 0, 0.4)",
    // Category colors — slightly brighter for dark bg contrast
    types: {
      note:    { color: "#B5A898", bg: "#2E2A25" },
      link:    { color: "#8AAFC8", bg: "#1E2830" },
      contact: { color: "#D4AA7C", bg: "#2E2518" },
      reading: { color: "#AE9BC8", bg: "#28202E" },
      food:    { color: "#D49A9A", bg: "#2E2020" },
      idea:    { color: "#8AC8B0", bg: "#1E2E25" },
      person:  { color: "#D4AA7C", bg: "#2E2518" },
      photo:   { color: "#C8B88E", bg: "#2E2A1E" },
      travel:  { color: "#7AB8D4", bg: "#1A2830" },
      work:    { color: "#9EA2C8", bg: "#22232E" },
      money:   { color: "#9EC894", bg: "#1E2E1A" },
      health:  { color: "#C898B5", bg: "#2E1E28" },
      media:   { color: "#D4A07A", bg: "#2E2518" },
      event:   { color: "#C8B87A", bg: "#2E2A1A" },
      recommended: { color: "#D4B07A", bg: "#2E2518" },
    },
  },
};

const typeLabels = {
  note:    { icon: "◦", label: "Note" },
  link:    { icon: "↗", label: "Link" },
  contact: { icon: "◯", label: "Contact" },
  reading: { icon: "▪", label: "Reading" },
  food:    { icon: "◦", label: "Food" },
  idea:    { icon: "✧", label: "Idea" },
  person:  { icon: "◯", label: "Person" },
  photo:   { icon: "▫", label: "Photo" },
  travel:  { icon: "△", label: "Travel" },
  work:    { icon: "▢", label: "Work" },
  money:   { icon: "◇", label: "Money" },
  health:  { icon: "♡", label: "Health" },
  media:   { icon: "♪", label: "Media" },
  event:   { icon: "☆", label: "Event" },
  recommended: { icon: "★", label: "Recommended" },
};

// ============================================================
// CUSTOM CATEGORY SUPPORT
// 
// Colors for user-created categories. When someone makes a
// new category, they get the next color in this rotation.
// ============================================================
const customColorPalette = [
  { light: { color: "#8A7EB5", bg: "#F0EEF8" }, dark: { color: "#A898C8", bg: "#25202E" } },
  { light: { color: "#5EBF8A", bg: "#EBF8F0" }, dark: { color: "#7AD4A0", bg: "#1A2E22" } },
  { light: { color: "#BF5E8A", bg: "#F8EBF0" }, dark: { color: "#D47AA0", bg: "#2E1A22" } },
  { light: { color: "#8ABF5E", bg: "#F0F8EB" }, dark: { color: "#A0D47A", bg: "#222E1A" } },
  { light: { color: "#BF8A5E", bg: "#F8F0EB" }, dark: { color: "#D4A07A", bg: "#2E2218" } },
  { light: { color: "#5E8ABF", bg: "#EBF0F8" }, dark: { color: "#7AA0D4", bg: "#1A222E" } },
];

// Gets type label info, checking custom categories as a fallback
const getTypeInfo = (type, customCategories = []) => {
  if (typeLabels[type]) return typeLabels[type];
  const custom = customCategories.find(c => c.id === type);
  if (custom) return { icon: custom.icon || "●", label: custom.label };
  return typeLabels.note;
};

// Gets type colors, checking custom categories as a fallback
const getTypeColors = (type, theme, customCategories = []) => {
  if (theme.types[type]) return theme.types[type];
  const custom = customCategories.find(c => c.id === type);
  if (custom) {
    const palette = customColorPalette[custom.colorIndex % customColorPalette.length];
    // Detect dark mode by checking background color
    const isDark = theme.pageBg === "#1C1A17";
    return isDark ? palette.dark : palette.light;
  }
  return theme.types.note;
};

// All available types (built-in + custom) for the category selector
const getAllTypes = (customCategories = []) => {
  const builtIn = Object.keys(typeLabels);
  const custom = customCategories.map(c => c.id);
  return [...builtIn, ...custom];
};

const readFileAsBase64 = (file) =>
  new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });

const compressImage = (dataUrl, maxWidth = 800) =>
  new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement("canvas");
      const ratio = Math.min(maxWidth / img.width, maxWidth / img.height, 1);
      canvas.width = img.width * ratio;
      canvas.height = img.height * ratio;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      resolve(canvas.toDataURL("image/jpeg", 0.7));
    };
    img.src = dataUrl;
  });

// ============================================================
// BUSINESS CARD OCR
// 
// Uses the Anthropic API to analyze a business card image and
// extract structured contact information. The API "sees" the
// image and returns name, title, company, phone, email, etc.
//
// We send the image as base64 and ask Claude to respond with
// JSON so we can parse it cleanly.
// ============================================================
const BACKEND_URL = "https://stash-server-production-1c71.up.railway.app";

// ============================================================
// API HELPER
//
// Wraps fetch() to attach the JWT token and handle errors.
// Every authenticated API call uses this function.
//
// NEW CONCEPT: "Bearer token"
// When a user logs in, the server gives them a token (a long
// string). For every API request after that, we send this token
// in the "Authorization" header so the server knows who we are.
// The format is: "Bearer <token>" — "Bearer" is just a keyword
// that tells the server "here comes a token."
// ============================================================
const apiFetch = async (path, options = {}) => {
  const token = localStorage.getItem("stash-token");
  const headers = {
    "Content-Type": "application/json",
    ...(token ? { Authorization: `Bearer ${token}` } : {}),
    ...options.headers,
  };

  const response = await fetch(`${BACKEND_URL}${path}`, {
    ...options,
    headers,
  });

  // If the server says our token is expired or invalid,
  // we need to log out and show the login screen again
  if (response.status === 401) {
    localStorage.removeItem("stash-token");
    // Dispatch a custom event so the Stash component can react
    window.dispatchEvent(new CustomEvent("auth-expired"));
    throw new Error("Session expired");
  }

  let data;
  try {
    data = await response.json();
  } catch {
    throw new Error("Server returned an unexpected response");
  }
  if (!response.ok) {
    throw new Error(data.error || "Request failed");
  }
  return data;
};

const extractBusinessCard = async (imageDataUrl) => {
  try {
    const response = await fetch(`${BACKEND_URL}/api/ocr`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ image: imageDataUrl }),
    });
    const data = await response.json();
    if (data.success) return data.data;
    console.error("OCR failed:", data.error);
    return null;
  } catch (err) {
    console.error("OCR failed:", err);
    return null;
  }
};


// Format extracted card data into readable text
const formatCardInfo = (card) => {
  const lines = [];
  if (card.name) lines.push(card.name);
  if (card.title && card.company) lines.push(`${card.title} at ${card.company}`);
  else if (card.title) lines.push(card.title);
  else if (card.company) lines.push(card.company);
  if (card.phone) lines.push(card.phone);
  if (card.email) lines.push(card.email);
  if (card.website) lines.push(card.website);
  if (card.address) lines.push(card.address);
  return lines.join("\n");
};

// ============================================================
// EXPORT DATA
// 
// Creates a JSON file of all your stash data and triggers a
// browser download. We use a "Blob" (binary large object) to
// create a temporary file URL, then simulate clicking a link.
// ============================================================
const exportData = (items, settings) => {
  const exportObj = {
    exportDate: new Date().toISOString(),
    version: "0.8",
    itemCount: items.length,
    items: items.map(({ image, ...rest }) => ({
      ...rest,
      hasImage: !!image, // Don't export full base64 images — too large
    })),
    settings: {
      timezone: settings.timezone,
      customCategories: settings.customCategories,
    },
  };

  const blob = new Blob([JSON.stringify(exportObj, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `stash-backup-${new Date().toISOString().slice(0, 10)}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

// Full export including images (larger file)
const exportDataFull = (items, settings) => {
  const exportObj = {
    exportDate: new Date().toISOString(),
    version: "0.8",
    itemCount: items.length,
    items: items,
    settings: {
      timezone: settings.timezone,
      customCategories: settings.customCategories,
    },
  };

  const blob = new Blob([JSON.stringify(exportObj, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `stash-full-backup-${new Date().toISOString().slice(0, 10)}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

// ============================================================
// IMAGE VIEWER
// ============================================================
const ImageViewer = ({ src, onClose, theme }) => (
  <div
    onClick={onClose}
    style={{
      position: "fixed", inset: 0,
      background: theme.overlayBg,
      backdropFilter: "blur(20px)",
      display: "flex", alignItems: "center", justifyContent: "center",
      zIndex: 1000, cursor: "zoom-out",
      animation: "softFadeIn 0.3s ease",
    }}
  >
    <img src={src} alt="Enlarged" style={{
      maxWidth: "88vw", maxHeight: "85vh",
      borderRadius: "16px", boxShadow: theme.shadowImage,
    }} />
    <div style={{
      position: "absolute", top: "24px", right: "28px",
      color: theme.textMuted, fontSize: "13px",
      fontFamily: "'Lora', serif", fontStyle: "italic",
    }}>tap anywhere to close</div>
  </div>
);

// ============================================================
// SETTINGS PANEL
// 
// This introduces "conditional rendering" — the panel only
// shows when settingsOpen is true. It slides in with an animation.
// ============================================================
// ============================================================
// CUSTOM CATEGORY FORM
// A mini form inside settings to create new categories
// ============================================================
const CustomCategoryForm = ({ onAdd, theme }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [label, setLabel] = useState("");
  const [icon, setIcon] = useState("●");
  const [keywords, setKeywords] = useState("");

  const handleAdd = () => {
    const trimmed = label.trim();
    if (!trimmed) return;
    const kwList = keywords.split(/[,\s]+/).map(k => k.trim().toLowerCase()).filter(k => k.length > 0);
    onAdd({ label: trimmed, icon, keywords: kwList });
    setLabel("");
    setIcon("●");
    setKeywords("");
    setIsOpen(false);
  };

  if (!isOpen) {
    return (
      <button
        onClick={() => setIsOpen(true)}
        style={{
          background: "none", border: `1px dashed ${theme.border}`,
          color: theme.textMuted, cursor: "pointer",
          borderRadius: "10px", padding: "8px 14px", width: "100%",
          fontSize: "13px", fontFamily: "'DM Sans', sans-serif",
          fontStyle: "italic", transition: "all 0.2s ease",
        }}
        onMouseEnter={e => { e.currentTarget.style.borderColor = theme.borderHover; e.currentTarget.style.color = theme.textSecondary; }}
        onMouseLeave={e => { e.currentTarget.style.borderColor = theme.border; e.currentTarget.style.color = theme.textMuted; }}
      >+ add category</button>
    );
  }

  return (
    <div style={{
      background: theme.hoverBg, borderRadius: "12px",
      padding: "14px", animation: "softFadeIn 0.2s ease",
    }}>
      <div style={{ display: "flex", gap: "8px", marginBottom: "8px" }}>
        {/* Icon picker — simple selection */}
        <select
          value={icon}
          onChange={e => setIcon(e.target.value)}
          style={{
            background: theme.cardBg, border: `1px solid ${theme.border}`,
            borderRadius: "8px", padding: "6px 8px", width: "48px",
            color: theme.textPrimary, fontSize: "14px", textAlign: "center",
            cursor: "pointer", appearance: "none", WebkitAppearance: "none",
          }}
        >
          {["●", "★", "♦", "▲", "■", "♥", "⬟", "◆", "⊕", "⌂"].map(i => (
            <option key={i} value={i}>{i}</option>
          ))}
        </select>
        {/* Name */}
        <input
          type="text"
          value={label}
          onChange={e => setLabel(e.target.value)}
          placeholder="Category name"
          maxLength={20}
          style={{
            flex: 1, background: theme.cardBg, border: `1px solid ${theme.border}`,
            borderRadius: "8px", padding: "6px 12px",
            color: theme.textPrimary, fontSize: "13px",
            fontFamily: "'DM Sans', sans-serif", outline: "none",
          }}
        />
      </div>
      <input
        type="text"
        value={keywords}
        onChange={e => setKeywords(e.target.value)}
        placeholder="Auto-detect keywords (comma separated)"
        style={{
          width: "100%", background: theme.cardBg, border: `1px solid ${theme.border}`,
          borderRadius: "8px", padding: "6px 12px", marginBottom: "10px",
          color: theme.textMuted, fontSize: "12px",
          fontFamily: "'DM Sans', sans-serif", outline: "none",
        }}
      />
      <div style={{ display: "flex", gap: "8px" }}>
        <button
          onClick={handleAdd}
          disabled={!label.trim()}
          style={{
            background: label.trim() ? theme.accentGradient : theme.disabledBg,
            border: "none", color: label.trim() ? "#FAF7F2" : theme.disabledText,
            borderRadius: "8px", padding: "6px 16px", fontSize: "12px",
            fontFamily: "'DM Sans', sans-serif", fontWeight: 500,
            cursor: label.trim() ? "pointer" : "default",
          }}
        >Create</button>
        <button
          onClick={() => { setIsOpen(false); setLabel(""); setKeywords(""); }}
          style={{
            background: "none", border: `1px solid ${theme.border}`,
            color: theme.textMuted, borderRadius: "8px",
            padding: "6px 16px", fontSize: "12px",
            fontFamily: "'DM Sans', sans-serif", cursor: "pointer",
          }}
        >Cancel</button>
      </div>
    </div>
  );
};

const SettingsPanel = ({ isOpen, onClose, settings, onUpdateSettings, theme, itemCount, completedCount, onExport, onExportFull, onImport }) => {
  if (!isOpen) return null;

  return (
    <div
      onClick={onClose}
      style={{
        position: "fixed", inset: 0,
        background: theme.overlayBg,
        backdropFilter: "blur(16px)",
        zIndex: 900,
        display: "flex", alignItems: "center", justifyContent: "center",
        animation: "softFadeIn 0.25s ease",
      }}
    >
      <div
        onClick={e => e.stopPropagation()}
        style={{
          background: theme.settingsBg,
          borderRadius: "24px",
          border: `1px solid ${theme.border}`,
          padding: "36px 32px",
          width: "92%",
          maxWidth: "420px",
          maxHeight: "85vh",
          overflowY: "auto",
          boxShadow: theme.shadowHover,
          animation: "settingsIn 0.35s ease",
        }}
      >
        {/* Header */}
        <div style={{
          display: "flex", justifyContent: "space-between", alignItems: "center",
          marginBottom: "28px",
        }}>
          <h2 style={{
            fontFamily: "'Lora', serif", fontSize: "22px", fontWeight: 400,
            margin: 0, color: theme.textSecondary,
          }}>Settings</h2>
          <button onClick={onClose} style={{
            background: "none", border: "none", color: theme.textGhost,
            fontSize: "20px", cursor: "pointer", padding: "4px 8px",
            borderRadius: "8px", transition: "all 0.2s ease",
          }}
          onMouseEnter={e => { e.target.style.color = theme.textMuted; e.target.style.background = theme.hoverBg; }}
          onMouseLeave={e => { e.target.style.color = theme.textGhost; e.target.style.background = "none"; }}
          >×</button>
        </div>

        {/* Dark Mode Toggle */}
        <div style={{
          display: "flex", justifyContent: "space-between", alignItems: "center",
          padding: "16px 0",
          borderBottom: `1px solid ${theme.border}`,
        }}>
          <div>
            <div style={{
              fontFamily: "'DM Sans', sans-serif", fontSize: "14.5px",
              color: theme.textPrimary, fontWeight: 500, marginBottom: "3px",
            }}>Dark mode</div>
            <div style={{
              fontFamily: "'Lora', serif", fontSize: "12.5px",
              color: theme.textFaint, fontStyle: "italic",
            }}>Easier on the eyes at night</div>
          </div>
          {/* Toggle Switch */}
          <button
            onClick={() => onUpdateSettings({ ...settings, darkMode: !settings.darkMode })}
            style={{
              width: "48px", height: "28px", borderRadius: "14px",
              background: settings.darkMode ? theme.checkColor : theme.disabledBg,
              border: "none", cursor: "pointer", position: "relative",
              transition: "background 0.3s ease", flexShrink: 0,
            }}
          >
            <div style={{
              width: "22px", height: "22px", borderRadius: "50%",
              background: "#FFFFFF",
              position: "absolute", top: "3px",
              left: settings.darkMode ? "23px" : "3px",
              transition: "left 0.3s ease",
              boxShadow: "0 1px 4px rgba(0,0,0,0.15)",
            }} />
          </button>
        </div>

        {/* Auto-archive setting */}
        <div style={{
          display: "flex", justifyContent: "space-between", alignItems: "center",
          padding: "16px 0",
          borderBottom: `1px solid ${theme.border}`,
        }}>
          <div>
            <div style={{
              fontFamily: "'DM Sans', sans-serif", fontSize: "14.5px",
              color: theme.textPrimary, fontWeight: 500, marginBottom: "3px",
            }}>Auto-archive completed</div>
            <div style={{
              fontFamily: "'Lora', serif", fontSize: "12.5px",
              color: theme.textFaint, fontStyle: "italic",
            }}>Hide checked-off items after a while</div>
          </div>
          <select
            value={settings.autoArchiveDays}
            onChange={e => onUpdateSettings({ ...settings, autoArchiveDays: Number(e.target.value) })}
            style={{
              background: theme.hoverBg,
              border: `1px solid ${theme.border}`,
              borderRadius: "10px",
              padding: "7px 12px",
              color: theme.textSecondary,
              fontSize: "13px",
              fontFamily: "'DM Sans', sans-serif",
              cursor: "pointer",
              appearance: "none",
              WebkitAppearance: "none",
              flexShrink: 0,
            }}
          >
            <option value={0}>Never</option>
            <option value={1}>After 1 day</option>
            <option value={7}>After 7 days</option>
            <option value={30}>After 30 days</option>
          </select>
        </div>

        {/* Show completed toggle */}
        <div style={{
          display: "flex", justifyContent: "space-between", alignItems: "center",
          padding: "16px 0",
          borderBottom: `1px solid ${theme.border}`,
        }}>
          <div>
            <div style={{
              fontFamily: "'DM Sans', sans-serif", fontSize: "14.5px",
              color: theme.textPrimary, fontWeight: 500, marginBottom: "3px",
            }}>Show completed items</div>
            <div style={{
              fontFamily: "'Lora', serif", fontSize: "12.5px",
              color: theme.textFaint, fontStyle: "italic",
            }}>Keep checked-off items visible in your feed</div>
          </div>
          <button
            onClick={() => onUpdateSettings({ ...settings, showCompleted: !settings.showCompleted })}
            style={{
              width: "48px", height: "28px", borderRadius: "14px",
              background: settings.showCompleted ? theme.checkColor : theme.disabledBg,
              border: "none", cursor: "pointer", position: "relative",
              transition: "background 0.3s ease", flexShrink: 0,
            }}
          >
            <div style={{
              width: "22px", height: "22px", borderRadius: "50%",
              background: "#FFFFFF",
              position: "absolute", top: "3px",
              left: settings.showCompleted ? "23px" : "3px",
              transition: "left 0.3s ease",
              boxShadow: "0 1px 4px rgba(0,0,0,0.15)",
            }} />
          </button>
        </div>

        {/* Timezone selector */}
        <div style={{
          display: "flex", justifyContent: "space-between", alignItems: "center",
          padding: "16px 0",
          borderBottom: `1px solid ${theme.border}`,
        }}>
          <div>
            <div style={{
              fontFamily: "'DM Sans', sans-serif", fontSize: "14.5px",
              color: theme.textPrimary, fontWeight: 500, marginBottom: "3px",
            }}>Timezone</div>
            <div style={{
              fontFamily: "'Lora', serif", fontSize: "12.5px",
              color: theme.textFaint, fontStyle: "italic",
            }}>Timestamps display in 24-hour format</div>
          </div>
          <select
            value={settings.timezone}
            onChange={e => onUpdateSettings({ ...settings, timezone: e.target.value })}
            style={{
              background: theme.hoverBg,
              border: `1px solid ${theme.border}`,
              borderRadius: "10px",
              padding: "7px 12px",
              color: theme.textSecondary,
              fontSize: "13px",
              fontFamily: "'DM Sans', sans-serif",
              cursor: "pointer",
              appearance: "none",
              WebkitAppearance: "none",
              flexShrink: 0,
            }}
          >
            {timezoneOptions.map(tz => (
              <option key={tz.value} value={tz.value}>{tz.label}</option>
            ))}
          </select>
        </div>

        {/* Custom Categories */}
        <div style={{ padding: "16px 0", borderBottom: `1px solid ${theme.border}` }}>
          <div style={{
            fontFamily: "'DM Sans', sans-serif", fontSize: "14.5px",
            color: theme.textPrimary, fontWeight: 500, marginBottom: "3px",
          }}>Custom categories</div>
          <div style={{
            fontFamily: "'Lora', serif", fontSize: "12.5px",
            color: theme.textFaint, fontStyle: "italic", marginBottom: "12px",
          }}>Create your own with auto-detect keywords</div>

          {/* Existing custom categories */}
          {settings.customCategories.length > 0 && (
            <div style={{ display: "flex", flexDirection: "column", gap: "8px", marginBottom: "12px" }}>
              {settings.customCategories.map(cat => {
                const colors = getTypeColors(cat.id, theme, settings.customCategories);
                return (
                  <div key={cat.id} style={{
                    display: "flex", alignItems: "center", justifyContent: "space-between",
                    background: theme.hoverBg, borderRadius: "10px", padding: "8px 12px",
                  }}>
                    <div style={{ display: "flex", alignItems: "center", gap: "8px" }}>
                      <span style={{
                        fontSize: "11px", color: colors.color, background: colors.bg,
                        padding: "3px 10px", borderRadius: "20px",
                        fontFamily: "'DM Sans', sans-serif", fontWeight: 500,
                      }}>{cat.label}</span>
                      {cat.keywords.length > 0 && (
                        <span style={{
                          fontSize: "11px", color: theme.textGhost,
                          fontFamily: "'DM Sans', sans-serif", fontStyle: "italic",
                        }}>{cat.keywords.slice(0, 3).join(", ")}{cat.keywords.length > 3 ? "…" : ""}</span>
                      )}
                    </div>
                    <button
                      onClick={() => {
                        onUpdateSettings({
                          ...settings,
                          customCategories: settings.customCategories.filter(c => c.id !== cat.id),
                        });
                      }}
                      style={{
                        background: "none", border: "none", color: theme.textGhost,
                        cursor: "pointer", fontSize: "14px", padding: "2px 6px",
                        borderRadius: "6px", transition: "all 0.2s ease",
                      }}
                      onMouseEnter={e => { e.target.style.color = theme.deleteColor; }}
                      onMouseLeave={e => { e.target.style.color = theme.textGhost; }}
                    >×</button>
                  </div>
                );
              })}
            </div>
          )}

          {/* Add new custom category form */}
          <CustomCategoryForm
            onAdd={(cat) => {
              onUpdateSettings({
                ...settings,
                customCategories: [...settings.customCategories, {
                  ...cat,
                  id: cat.label.toLowerCase().replace(/\s+/g, "_"),
                  colorIndex: settings.customCategories.length,
                }],
              });
            }}
            theme={theme}
          />
        </div>

        {/* Stats */}
        <div style={{
          padding: "20px 0 4px",
          display: "flex", gap: "24px",
        }}>
          <div>
            <div style={{
              fontFamily: "'Lora', serif", fontSize: "24px",
              color: theme.textSecondary, fontWeight: 400,
            }}>{itemCount}</div>
            <div style={{
              fontFamily: "'DM Sans', sans-serif", fontSize: "12px",
              color: theme.textFaint, fontStyle: "italic",
            }}>stashed</div>
          </div>
          <div>
            <div style={{
              fontFamily: "'Lora', serif", fontSize: "24px",
              color: theme.checkColor, fontWeight: 400,
            }}>{completedCount}</div>
            <div style={{
              fontFamily: "'DM Sans', sans-serif", fontSize: "12px",
              color: theme.textFaint, fontStyle: "italic",
            }}>completed</div>
          </div>
        </div>

        {/* Export */}
        <div style={{
          padding: "16px 0 4px",
          borderTop: `1px solid ${theme.border}`,
          marginTop: "16px",
        }}>
          <div style={{
            fontFamily: "'DM Sans', sans-serif", fontSize: "14.5px",
            color: theme.textPrimary, fontWeight: 500, marginBottom: "3px",
          }}>Export your data</div>
          <div style={{
            fontFamily: "'Lora', serif", fontSize: "12.5px",
            color: theme.textFaint, fontStyle: "italic", marginBottom: "12px",
          }}>Download a backup of all your stashes</div>
          <div style={{ display: "flex", gap: "8px" }}>
            <button
              onClick={onExport}
              style={{
                background: theme.hoverBg, border: `1px solid ${theme.border}`,
                color: theme.textSecondary, borderRadius: "10px",
                padding: "8px 16px", fontSize: "13px",
                fontFamily: "'DM Sans', sans-serif",
                cursor: "pointer", transition: "all 0.2s ease",
              }}
              onMouseEnter={e => { e.currentTarget.style.borderColor = theme.borderHover; }}
              onMouseLeave={e => { e.currentTarget.style.borderColor = theme.border; }}
            >Text backup</button>
            <button
              onClick={onExportFull}
              style={{
                background: theme.hoverBg, border: `1px solid ${theme.border}`,
                color: theme.textSecondary, borderRadius: "10px",
                padding: "8px 16px", fontSize: "13px",
                fontFamily: "'DM Sans', sans-serif",
                cursor: "pointer", transition: "all 0.2s ease",
              }}
              onMouseEnter={e => { e.currentTarget.style.borderColor = theme.borderHover; }}
              onMouseLeave={e => { e.currentTarget.style.borderColor = theme.border; }}
            >Full backup (with images)</button>
          </div>
        </div>

        {/* Import */}
        <div style={{
          padding: "16px 0 4px",
          borderTop: `1px solid ${theme.border}`,
          marginTop: "16px",
        }}>
          <div style={{
            fontFamily: "'DM Sans', sans-serif", fontSize: "14.5px",
            color: theme.textPrimary, fontWeight: 500, marginBottom: "3px",
          }}>Import backup</div>
          <div style={{
            fontFamily: "'Lora', serif", fontSize: "12.5px",
            color: theme.textFaint, fontStyle: "italic", marginBottom: "12px",
          }}>Restore from a previously exported backup file</div>
          <label style={{
            display: "inline-block",
            background: theme.hoverBg, border: `1px solid ${theme.border}`,
            color: theme.textSecondary, borderRadius: "10px",
            padding: "8px 16px", fontSize: "13px",
            fontFamily: "'DM Sans', sans-serif",
            cursor: "pointer", transition: "all 0.2s ease",
          }}>
            Choose file…
            <input
              type="file"
              accept=".json"
              style={{ display: "none" }}
              onChange={(e) => {
                const file = e.target.files?.[0];
                if (file) {
                  const reader = new FileReader();
                  reader.onload = (evt) => {
                    try {
                      const data = JSON.parse(evt.target.result);
                      onImport(data);
                    } catch (err) {
                      alert("Couldn't read that file. Make sure it's a Stash backup (.json).");
                    }
                  };
                  reader.readAsText(file);
                }
                e.target.value = "";
              }}
            />
          </label>
        </div>
      </div>
    </div>
  );
};

// ============================================================
// STASH CARD — with inline editing!
// 
// NEW CONCEPT: "Inline editing"
// Instead of opening a separate edit screen (like a modal or
// new page), we transform the card ITSELF into an editable
// state. The content text becomes a textarea, tags become
// editable, and Save/Cancel buttons appear.
//
// This uses a LOCAL state (isEditing) inside the component.
// The card manages its own edit mode independently — this is
// called "component-level state" vs "app-level state."
// ============================================================
const StashCard = ({ item, onDelete, onToggleComplete, onEdit, onViewImage, onTogglePin, onScanCard, isScanning, theme, timezone, customCategories, isSlidingOut, bulkMode, isSelected, onToggleBulkSelect }) => {
  const typeInfo = getTypeInfo(item.type, customCategories);
  const typeColors = getTypeColors(item.type, theme, customCategories);
  const isCompleted = item.completed;

  // LOCAL state — only this card knows if it's being edited
  const [isEditing, setIsEditing] = useState(false);
  const [editContent, setEditContent] = useState(item.content);
  const [editTags, setEditTags] = useState(item.tags.join(", "));
  const [copied, setCopied] = useState(false);
  const editRef = useRef(null);

  const isContact = item.type === "contact" || item.type === "person" || item.ocrData;

  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(item.content);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      // Fallback for older browsers
      const ta = document.createElement("textarea");
      ta.value = item.content;
      ta.style.position = "fixed";
      ta.style.opacity = "0";
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      document.body.removeChild(ta);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    }
  };

  // When entering edit mode, focus the textarea
  useEffect(() => {
    if (isEditing && editRef.current) {
      editRef.current.focus();
      // Move cursor to end of text
      editRef.current.selectionStart = editRef.current.value.length;
    }
  }, [isEditing]);

  const startEditing = () => {
    if (isCompleted) return; // don't allow editing completed items
    setEditContent(item.content);
    setEditTags(item.tags.join(", "));
    setIsEditing(true);
  };

  const cancelEditing = () => {
    setIsEditing(false);
    setEditContent(item.content);
    setEditTags(item.tags.join(", "));
  };

  const saveEdit = () => {
    const newContent = editContent.trim();
    if (!newContent && !item.image) { cancelEditing(); return; }
    
    // Parse tags: support both "tag1, tag2" and "#tag1 #tag2" formats
    const newTags = editTags
      .split(/[,\s]+/)
      .map(t => t.replace(/^#/, "").trim().toLowerCase())
      .filter(t => t.length > 0);

    onEdit(item.id, {
      content: newContent,
      tags: newTags,
      type: item.image ? "photo" : detectType(newContent, customCategories),
    });
    setIsEditing(false);
  };

  const handleEditKeyDown = (e) => {
    if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); saveEdit(); }
    if (e.key === "Escape") { cancelEditing(); }
  };

  return (
    <div
      onClick={bulkMode ? () => onToggleBulkSelect(item.id) : undefined}
      style={{
      background: isEditing ? theme.cardBg : (isSelected ? (theme.pageBg === "#1C1A17" ? "#2A2724" : "#F0EDE6") : (isCompleted ? theme.completedBg : theme.cardBg)),
      borderRadius: "16px",
      padding: "16px 18px",
      marginBottom: "8px",
      border: `1px solid ${isSelected ? theme.accent + "66" : (isEditing ? theme.borderHover : (item.pinned ? theme.checkColor + "44" : theme.border))}`,
      transition: "all 0.35s ease",
      cursor: bulkMode ? "pointer" : "default",
      animation: isSlidingOut ? "slideOut 0.3s ease forwards" : "cardIn 0.4s ease forwards",
      position: "relative",
      opacity: isCompleted && !isSlidingOut ? 0.6 : 1,
      boxShadow: isEditing ? theme.shadowHover : (isCompleted ? "none" : theme.shadowLight),
      borderLeft: item.pinned && !isSelected ? `3px solid ${theme.checkColor}66` : undefined,
    }}
    onMouseEnter={e => {
      if (!isCompleted && !isEditing && !bulkMode) {
        e.currentTarget.style.boxShadow = theme.shadowHover;
        e.currentTarget.style.transform = "translateY(-1px)";
      }
    }}
    onMouseLeave={e => {
      if (!isEditing && !bulkMode) {
        e.currentTarget.style.boxShadow = isCompleted ? "none" : theme.shadowLight;
        e.currentTarget.style.transform = "translateY(0)";
      }
    }}
    >
      <div style={{ display: "flex", gap: "14px", alignItems: "flex-start" }}>
        {/* Check button or bulk select indicator */}
        {bulkMode ? (
          <div style={{
            width: "24px", height: "24px", borderRadius: "6px",
            border: `2px solid ${isSelected ? theme.accent : theme.borderHover}`,
            background: isSelected ? theme.accent : "transparent",
            display: "flex", alignItems: "center", justifyContent: "center",
            flexShrink: 0, marginTop: "2px", transition: "all 0.2s ease",
            color: isSelected ? "#FAF7F2" : "transparent", fontSize: "13px", fontWeight: 700,
          }}>
            {isSelected ? "✓" : ""}
          </div>
        ) : (
        <button
          onClick={() => { if (isEditing) return; onToggleComplete(item.id); }}
          title={isCompleted ? "Mark as active" : "Mark as done"}
          style={{
            width: "24px", height: "24px", borderRadius: "50%",
            border: isCompleted
              ? `2px solid ${theme.checkColor}`
              : `2px solid ${theme.borderHover}`,
            background: isCompleted ? theme.checkBg : "transparent",
            cursor: isEditing ? "default" : "pointer",
            display: "flex", alignItems: "center", justifyContent: "center",
            flexShrink: 0, marginTop: "2px",
            transition: "all 0.25s ease",
            color: isCompleted ? theme.checkColor : "transparent",
            fontSize: "12px",
            opacity: isEditing ? 0.4 : 1,
          }}
          onMouseEnter={e => {
            if (!isCompleted && !isEditing) {
              e.currentTarget.style.borderColor = theme.checkColor;
              e.currentTarget.style.background = theme.checkBg;
              e.currentTarget.style.color = theme.checkColor;
            }
          }}
          onMouseLeave={e => {
            if (!isCompleted && !isEditing) {
              e.currentTarget.style.borderColor = theme.borderHover;
              e.currentTarget.style.background = "transparent";
              e.currentTarget.style.color = "transparent";
            }
          }}
        >✓</button>
        )}

        <div style={{ flex: 1, minWidth: 0 }}>
          {/* Type pill + time */}
          <div style={{ display: "flex", alignItems: "center", gap: "10px", marginBottom: "8px" }}>
            <span style={{
              fontSize: "11px",
              color: typeColors.color,
              background: typeColors.bg,
              padding: "4px 12px",
              borderRadius: "24px",
              fontFamily: "'DM Sans', sans-serif",
              fontWeight: 500,
              letterSpacing: "0.03em",
              opacity: isCompleted ? 0.6 : 1,
            }}>
              {typeInfo.label}
            </span>
            <span style={{
              fontSize: "12px",
              color: theme.textGhost,
              fontFamily: "'Lora', serif",
              fontStyle: "italic",
            }}>{formatDateTime(item.createdAt, timezone)}</span>
            {isCompleted && (
              <span style={{
                fontSize: "11px",
                color: theme.checkColor,
                fontFamily: "'DM Sans', sans-serif",
                fontStyle: "italic",
              }}>done</span>
            )}
            {item.pinned && !isCompleted && (
              <span style={{
                fontSize: "11px",
                color: theme.textMuted,
                fontFamily: "'DM Sans', sans-serif",
                fontStyle: "italic",
              }}>pinned</span>
            )}
            {item.ocrData && (
              <span style={{
                fontSize: "11px",
                color: theme.textMuted,
                fontFamily: "'DM Sans', sans-serif",
                fontStyle: "italic",
              }}>scanned</span>
            )}
          </div>

          {/* Image */}
          {item.image && (
            <div
              onClick={() => !isEditing && onViewImage(item.image)}
              style={{
                marginBottom: "10px", cursor: isEditing ? "default" : "zoom-in",
                borderRadius: "12px", overflow: "hidden",
                maxWidth: "280px", border: `1px solid ${theme.border}`,
                transition: "all 0.3s ease",
                opacity: isCompleted ? 0.7 : 1,
                position: "relative",
              }}
            >
              <img src={item.image} alt={item.content || "Stashed image"}
                style={{ width: "100%", display: "block", maxHeight: "200px", objectFit: "cover" }}
              />
              {isScanning && (
                <div style={{
                  position: "absolute", top: 0, left: 0, right: 0, bottom: 0,
                  background: "rgba(0, 0, 0, 0.45)",
                  display: "flex", alignItems: "center", justifyContent: "center",
                  borderRadius: "12px",
                }}>
                  <span style={{
                    color: "#FFFFFF", fontSize: "13px",
                    fontFamily: "'DM Sans', sans-serif", fontWeight: 500,
                    animation: "gentlePulse 1.5s ease infinite",
                  }}>Scanning...</span>
                </div>
              )}
            </div>
          )}

          {/* ===== EDIT MODE vs DISPLAY MODE ===== */}
          {isEditing ? (
            // --- EDIT MODE ---
            <div style={{ animation: "softFadeIn 0.2s ease" }}>
              {/* Editable content */}
              <textarea
                ref={editRef}
                value={editContent}
                onChange={e => setEditContent(e.target.value)}
                onKeyDown={handleEditKeyDown}
                rows={2}
                style={{
                  width: "100%",
                  background: theme.hoverBg,
                  border: `1px solid ${theme.border}`,
                  borderRadius: "10px",
                  color: theme.textPrimary,
                  fontSize: "15px",
                  fontFamily: "'Lora', serif",
                  padding: "10px 14px",
                  resize: "vertical",
                  lineHeight: "1.6",
                  minHeight: "44px",
                  outline: "none",
                }}
                onInput={e => {
                  e.target.style.height = "auto";
                  e.target.style.height = Math.min(e.target.scrollHeight, 160) + "px";
                }}
              />

              {/* Editable tags */}
              <div style={{ marginTop: "8px" }}>
                <input
                  type="text"
                  value={editTags}
                  onChange={e => setEditTags(e.target.value)}
                  onKeyDown={handleEditKeyDown}
                  placeholder="tags (comma or space separated)"
                  style={{
                    width: "100%",
                    background: theme.hoverBg,
                    border: `1px solid ${theme.border}`,
                    borderRadius: "10px",
                    color: theme.textMuted,
                    fontSize: "13px",
                    fontFamily: "'DM Sans', sans-serif",
                    padding: "8px 14px",
                    outline: "none",
                  }}
                />
              </div>

              {/* Save / Cancel buttons */}
              <div style={{ display: "flex", gap: "8px", marginTop: "12px" }}>
                <button
                  onClick={saveEdit}
                  style={{
                    background: theme.accentGradient,
                    border: "none",
                    color: "#FAF7F2",
                    borderRadius: "10px",
                    padding: "7px 18px",
                    fontSize: "13px",
                    fontFamily: "'DM Sans', sans-serif",
                    fontWeight: 500,
                    cursor: "pointer",
                    transition: "all 0.2s ease",
                  }}
                >Save</button>
                <button
                  onClick={cancelEditing}
                  style={{
                    background: "none",
                    border: `1px solid ${theme.border}`,
                    color: theme.textMuted,
                    borderRadius: "10px",
                    padding: "7px 18px",
                    fontSize: "13px",
                    fontFamily: "'DM Sans', sans-serif",
                    cursor: "pointer",
                    transition: "all 0.2s ease",
                  }}
                  onMouseEnter={e => { e.currentTarget.style.borderColor = theme.borderHover; }}
                  onMouseLeave={e => { e.currentTarget.style.borderColor = theme.border; }}
                >Cancel</button>
              </div>

              <div style={{
                marginTop: "8px", fontSize: "11px", color: theme.textGhost,
                fontFamily: "'DM Sans', sans-serif", fontStyle: "italic",
              }}>enter to save · esc to cancel</div>
            </div>
          ) : (
            // --- DISPLAY MODE (click content to edit) ---
            <div>
              {item.content && (
                <p
                  onClick={startEditing}
                  style={{
                    margin: 0,
                    color: theme.textPrimary,
                    fontSize: "15.5px",
                    lineHeight: "1.65",
                    fontFamily: "'Lora', serif",
                    wordBreak: "break-word",
                    whiteSpace: "pre-wrap",
                    textDecoration: isCompleted ? "line-through" : "none",
                    textDecorationColor: theme.textGhost,
                    cursor: isCompleted ? "default" : "text",
                    borderRadius: "6px",
                    padding: "2px 0",
                    transition: "background 0.2s ease",
                  }}
                  onMouseEnter={e => { if (!isCompleted) e.currentTarget.style.background = theme.hoverBg; }}
                  onMouseLeave={e => { e.currentTarget.style.background = "transparent"; }}
                  title={isCompleted ? "" : "Click to edit"}
                >{item.content}</p>
              )}

              {item.tags && item.tags.length > 0 && (
                <div
                  onClick={startEditing}
                  style={{
                    display: "flex", gap: "6px", marginTop: "10px", flexWrap: "wrap",
                    cursor: isCompleted ? "default" : "pointer",
                  }}
                >
                  {item.tags.map(tag => (
                    <span key={tag} style={{
                      fontSize: "11.5px",
                      color: theme.textMuted,
                      background: theme.hoverBg,
                      padding: "3px 10px",
                      borderRadius: "8px",
                      fontFamily: "'DM Sans', sans-serif",
                    }}>#{tag}</span>
                  ))}
                </div>
              )}

              {/* Copy / Add Contact buttons for contact-type items */}
              {isContact && item.content && !isEditing && (
                <div style={{
                  display: "flex", gap: "8px", marginTop: "12px",
                  animation: "softFadeIn 0.2s ease",
                }}>
                  <button
                    onClick={(e) => { e.stopPropagation(); copyToClipboard(); }}
                    style={{
                      background: copied ? theme.checkBg : theme.hoverBg,
                      border: `1px solid ${copied ? theme.checkColor + "44" : theme.border}`,
                      color: copied ? theme.checkColor : theme.textMuted,
                      borderRadius: "10px",
                      padding: "6px 14px",
                      fontSize: "12px",
                      fontFamily: "'DM Sans', sans-serif",
                      cursor: "pointer",
                      transition: "all 0.25s ease",
                      fontWeight: 500,
                    }}
                    onMouseEnter={e => { if (!copied) { e.currentTarget.style.borderColor = theme.borderHover; e.currentTarget.style.color = theme.textSecondary; } }}
                    onMouseLeave={e => { if (!copied) { e.currentTarget.style.borderColor = theme.border; e.currentTarget.style.color = theme.textMuted; } }}
                  >
                    {copied ? "Copied" : "Copy info"}
                  </button>
                </div>
              )}

              {/* Subtle edit hint for items without content (photo-only) */}
              {!item.content && !isCompleted && (
                <button
                  onClick={startEditing}
                  style={{
                    background: "none", border: "none",
                    color: theme.textGhost, cursor: "pointer",
                    fontSize: "13px", fontFamily: "'Lora', serif",
                    fontStyle: "italic", padding: "4px 0",
                    transition: "color 0.2s ease",
                  }}
                  onMouseEnter={e => { e.currentTarget.style.color = theme.textMuted; }}
                  onMouseLeave={e => { e.currentTarget.style.color = theme.textGhost; }}
                >+ add a note…</button>
              )}
            </div>
          )}
        </div>

        {/* Action buttons — clean horizontal row */}
        {!isEditing && (
          <div style={{
            display: "flex", gap: "2px", flexShrink: 0,
            alignItems: "flex-start",
          }}>
            <button
              onClick={() => onTogglePin(item.id)}
              style={{
                background: item.pinned ? theme.checkBg : "none",
                border: "none",
                color: item.pinned ? theme.checkColor : theme.textGhost,
                cursor: "pointer",
                fontSize: "11px", padding: "4px 8px",
                borderRadius: "6px", transition: "all 0.25s ease",
                fontFamily: "'DM Sans', sans-serif", fontWeight: 500,
              }}
              onMouseEnter={e => { if (!item.pinned) { e.target.style.color = theme.textMuted; e.target.style.background = theme.hoverBg; } }}
              onMouseLeave={e => { if (!item.pinned) { e.target.style.color = theme.textGhost; e.target.style.background = "none"; } }}
              title={item.pinned ? "Unpin" : "Pin to top"}
            >{item.pinned ? "Pinned" : "Pin"}</button>
            {item.image && !item.ocrData && (
              <button
                onClick={() => onScanCard(item.id)}
                disabled={isScanning}
                style={{
                  background: "none", border: "none",
                  color: isScanning ? theme.textMuted : theme.textGhost,
                  cursor: isScanning ? "wait" : "pointer",
                  fontSize: "11px", padding: "4px 8px",
                  borderRadius: "6px", transition: "all 0.25s ease",
                  fontFamily: "'DM Sans', sans-serif", fontWeight: 500,
                  animation: isScanning ? "gentlePulse 1.5s ease infinite" : "none",
                }}
                onMouseEnter={e => { if (!isScanning) { e.target.style.color = theme.textMuted; e.target.style.background = theme.hoverBg; } }}
                onMouseLeave={e => { if (!isScanning) { e.target.style.color = theme.textGhost; e.target.style.background = "none"; } }}
              >{isScanning ? "Scanning…" : "Scan"}</button>
            )}
            <button
              onClick={() => onDelete(item.id)}
              style={{
                background: "none", border: "none",
                color: theme.textGhost, cursor: "pointer",
                fontSize: "15px", padding: "3px 7px",
                borderRadius: "6px", transition: "all 0.25s ease",
                lineHeight: 1,
              }}
              onMouseEnter={e => { e.target.style.color = theme.deleteColor; e.target.style.background = theme.deleteBg; }}
              onMouseLeave={e => { e.target.style.color = theme.textGhost; e.target.style.background = "none"; }}
              title="Remove"
            >×</button>
          </div>
        )}
      </div>
    </div>
  );
};

// ============================================================
// EMPTY STATE
// ============================================================
const EmptyState = ({ theme }) => (
  <div style={{ textAlign: "center", padding: "72px 24px" }}>
    <div style={{
      width: "64px", height: "64px", borderRadius: "50%",
      background: theme.hoverBg, margin: "0 auto 20px",
      display: "flex", alignItems: "center", justifyContent: "center",
      fontSize: "24px", color: theme.textGhost, border: `1px solid ${theme.border}`,
    }}>✧</div>
    <p style={{
      fontFamily: "'Lora', serif", fontSize: "21px",
      color: theme.textSecondary, margin: "0 0 8px",
    }}>Your stash is empty</p>
    <p style={{
      fontFamily: "'DM Sans', sans-serif", fontSize: "14px",
      color: theme.textFaint, margin: 0, lineHeight: 1.6,
    }}>Type a thought, drop a photo, or save a link<br/>— everything goes here</p>
  </div>
);

// ============================================================
// LOGIN SCREEN
//
// Full-page login/signup form. Rendered when the user has no
// valid JWT token. Uses the same theme system as the rest of
// the app.
//
// NEW CONCEPTS:
// - "Controlled form" — React controls the input values via
//   state (email, password). Every keystroke updates state,
//   and the input always shows the current state value.
//
// - "Form submission" — We prevent the browser's default form
//   submit (which would reload the page) and handle it ourselves
//   with an API call.
//
// - "authMode" toggle — Instead of two separate pages, we use
//   one component with a state variable that switches between
//   "login" and "signup" mode. The form fields are the same,
//   just the button text and API endpoint change.
// ============================================================
const LoginScreen = ({ onLogin, theme }) => {
  const [authMode, setAuthMode] = useState("login");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      const endpoint = authMode === "login" ? "/api/auth/login" : "/api/auth/signup";
      const response = await fetch(`${BACKEND_URL}${endpoint}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, password }),
      });
      let data;
      try {
        data = await response.json();
      } catch {
        throw new Error("Server returned an unexpected response. Try again in a moment.");
      }

      if (!response.ok) {
        throw new Error(data.error || "Something went wrong");
      }

      // Save the token and tell the parent component
      localStorage.setItem("stash-token", data.token);
      onLogin(data.token, data.user);
    } catch (err) {
      if (err instanceof TypeError) {
        setError("Unable to reach the server. Check your connection and try again.");
      } else {
        setError(err.message);
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <div style={{
      minHeight: "100vh",
      background: theme.pageBg,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      fontFamily: "'DM Sans', sans-serif",
      transition: "background 0.4s ease",
    }}>
      <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,500;0,600;1,400;1,500&family=DM+Sans:ital,wght@0,300;0,400;0,500;1,300;1,400&display=swap" rel="stylesheet" />

      <div style={{
        width: "92%",
        maxWidth: "380px",
        animation: "softFadeIn 0.6s ease",
      }}>
        {/* Branding */}
        <div style={{ textAlign: "center", marginBottom: "36px" }}>
          <h1 style={{
            fontFamily: "'Lora', serif",
            fontSize: "36px",
            fontWeight: 400,
            color: theme.textSecondary,
            letterSpacing: "-0.02em",
            margin: "0 0 6px",
          }}>Stash</h1>
          <p style={{
            fontFamily: "'Lora', serif",
            fontSize: "14px",
            color: theme.textGhost,
            fontStyle: "italic",
            margin: 0,
          }}>your personal memory bank</p>
        </div>

        {/* Form card */}
        <div style={{
          background: theme.cardBg,
          borderRadius: "20px",
          border: `1px solid ${theme.border}`,
          padding: "32px 28px",
          boxShadow: theme.shadowMedium,
        }}>
          <form onSubmit={handleSubmit}>
            {/* Email */}
            <div style={{ marginBottom: "18px" }}>
              <label style={{
                display: "block",
                fontFamily: "'DM Sans', sans-serif",
                fontSize: "13px",
                fontWeight: 500,
                color: theme.textMuted,
                marginBottom: "6px",
              }}>Email</label>
              <input
                type="email"
                value={email}
                onChange={(e) => { setEmail(e.target.value); setError(""); }}
                placeholder="you@example.com"
                required
                autoComplete="email"
                style={{
                  width: "100%",
                  padding: "12px 14px",
                  borderRadius: "12px",
                  border: `1px solid ${theme.border}`,
                  background: theme.inputBg,
                  color: theme.textPrimary,
                  fontFamily: "'DM Sans', sans-serif",
                  fontSize: "15px",
                  outline: "none",
                  boxSizing: "border-box",
                  transition: "border-color 0.2s ease",
                }}
                onFocus={(e) => e.target.style.borderColor = theme.borderHover}
                onBlur={(e) => e.target.style.borderColor = theme.border}
              />
            </div>

            {/* Password */}
            <div style={{ marginBottom: "24px" }}>
              <label style={{
                display: "block",
                fontFamily: "'DM Sans', sans-serif",
                fontSize: "13px",
                fontWeight: 500,
                color: theme.textMuted,
                marginBottom: "6px",
              }}>Password</label>
              <input
                type="password"
                value={password}
                onChange={(e) => { setPassword(e.target.value); setError(""); }}
                placeholder={authMode === "signup" ? "8+ characters" : ""}
                required
                autoComplete={authMode === "login" ? "current-password" : "new-password"}
                style={{
                  width: "100%",
                  padding: "12px 14px",
                  borderRadius: "12px",
                  border: `1px solid ${theme.border}`,
                  background: theme.inputBg,
                  color: theme.textPrimary,
                  fontFamily: "'DM Sans', sans-serif",
                  fontSize: "15px",
                  outline: "none",
                  boxSizing: "border-box",
                  transition: "border-color 0.2s ease",
                }}
                onFocus={(e) => e.target.style.borderColor = theme.borderHover}
                onBlur={(e) => e.target.style.borderColor = theme.border}
              />
            </div>

            {/* Error message */}
            {error && (
              <div style={{
                color: theme.deleteColor,
                fontSize: "13px",
                fontFamily: "'DM Sans', sans-serif",
                marginBottom: "16px",
                textAlign: "center",
              }}>{error}</div>
            )}

            {/* Submit button */}
            <button
              type="submit"
              disabled={loading}
              style={{
                width: "100%",
                padding: "13px",
                borderRadius: "12px",
                border: "none",
                background: loading ? theme.disabledBg : theme.accentGradient,
                color: loading ? theme.disabledText : "#FFFFFF",
                fontFamily: "'DM Sans', sans-serif",
                fontSize: "15px",
                fontWeight: 500,
                cursor: loading ? "default" : "pointer",
                transition: "opacity 0.2s ease",
              }}
            >
              {loading
                ? (authMode === "login" ? "Logging in..." : "Creating account...")
                : (authMode === "login" ? "Log in" : "Create account")}
            </button>
          </form>

          {/* Toggle login/signup */}
          <div style={{
            textAlign: "center",
            marginTop: "20px",
            fontSize: "13px",
            color: theme.textFaint,
            fontFamily: "'DM Sans', sans-serif",
          }}>
            {authMode === "login" ? (
              <span>
                Don't have an account?{" "}
                <span
                  onClick={() => { setAuthMode("signup"); setError(""); }}
                  style={{ color: theme.accent, cursor: "pointer", fontWeight: 500 }}
                >Sign up</span>
              </span>
            ) : (
              <span>
                Already have an account?{" "}
                <span
                  onClick={() => { setAuthMode("login"); setError(""); }}
                  style={{ color: theme.accent, cursor: "pointer", fontWeight: 500 }}
                >Log in</span>
              </span>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

// ============================================================
// MAIN APP
// ============================================================
function Stash() {
  // --- Auth state ---
  const [token, setToken] = useState(localStorage.getItem("stash-token"));
  const [user, setUser] = useState(null);
  const [authLoading, setAuthLoading] = useState(!!localStorage.getItem("stash-token"));
  const [authError, setAuthError] = useState("");

  // Listen for auth-expired events from apiFetch
  useEffect(() => {
    const handleAuthExpired = () => {
      localStorage.removeItem("stash-token");
      setToken(null);
      setUser(null);
      setItems([]);
      setAuthError("Session expired. Please log in again.");
    };
    window.addEventListener("auth-expired", handleAuthExpired);
    return () => window.removeEventListener("auth-expired", handleAuthExpired);
  }, []);

  // Called by LoginScreen after successful login/signup
  const handleLogin = async (newToken, userData) => {
    setToken(newToken);
    setUser(userData);
    setAuthError("");
    setAuthLoading(true);

    try {
      // Check for localStorage stashes to migrate
      const localData = localStorage.getItem("stash-items");
      if (localData) {
        let localStashes;
        try {
          localStashes = JSON.parse(localData);
        } catch (parseErr) {
          console.error("[Auth] Corrupt local data, skipping migration:", parseErr);
          localStorage.removeItem("stash-items");
          localStashes = [];
        }
        if (localStashes.length > 0) {
          try {
            await apiFetch("/api/stashes/import", {
              method: "POST",
              body: JSON.stringify({ stashes: localStashes }),
            });
            // Only clear localStorage after successful migration
            localStorage.removeItem("stash-items");
          } catch (importErr) {
            console.error("[Auth] Migration import failed, keeping local data:", importErr.message);
          }
        }
      }

      // Fetch all stashes from the server
      const data = await apiFetch("/api/stashes");
      setItems(data.stashes);
    } catch (err) {
      console.error("[Auth] Failed to load stashes:", err.message);
      setAuthError("Logged in, but couldn't load your stashes. Please refresh to try again.");
    } finally {
      setAuthLoading(false);
      setIsLoading(false);
    }
  };

  const handleLogout = () => {
    localStorage.removeItem("stash-token");
    setToken(null);
    setUser(null);
    setItems([]);
  };

  const [items, setItems] = useState([]);
  const [inputValue, setInputValue] = useState("");
  const [searchQuery, setSearchQuery] = useState("");
  const [filterType, setFilterType] = useState("all");
  const [isLoading, setIsLoading] = useState(true);
  const [isDragging, setIsDragging] = useState(false);
  const [pendingImage, setPendingImage] = useState(null);
  const [viewingImage, setViewingImage] = useState(null);
  const [settingsOpen, setSettingsOpen] = useState(false);
  const [completedExpanded, setCompletedExpanded] = useState(true);
  const [selectedType, setSelectedType] = useState("auto");
  const [sortOrder, setSortOrder] = useState("newest");     // "newest", "oldest"
  const [undoItem, setUndoItem] = useState(null);           // recently deleted item for undo
  const [undoTimer, setUndoTimer] = useState(null);         // timeout ref for auto-clearing undo
  const [bulkMode, setBulkMode] = useState(false);          // bulk select mode
  const [bulkSelected, setBulkSelected] = useState(new Set()); // selected item IDs
  const [slidingOut, setSlidingOut] = useState(new Set());   // items currently animating out
  const [confirmClearAll, setConfirmClearAll] = useState(false); // confirm before clearing completed
  const [settings, setSettings] = useState({
    darkMode: false,
    autoArchiveDays: 0,
    showCompleted: true,
    timezone: "America/New_York",
    customCategories: [],  // NEW: user-created categories [{id, label, icon, keywords: [], colorIndex}]
  });
  const inputRef = useRef(null);
  const dragCounterRef = useRef(0);

  // Current theme based on settings
  const theme = settings.darkMode ? themes.dark : themes.light;

  // Load data on mount
  useEffect(() => {
    const loadData = async () => {
      // Load settings from localStorage (stays local, not synced)
      try {
        const settingsResult = await window.storage.get("stash-settings");
        if (settingsResult?.value) setSettings(prev => ({ ...prev, ...JSON.parse(settingsResult.value) }));
      } catch (e) {}

      // If we have a token, try loading stashes from the server
      if (token) {
        try {
          const data = await apiFetch("/api/stashes");
          setItems(data.stashes);
          setAuthLoading(false);
          setIsLoading(false);
        } catch (err) {
          // Token is invalid or expired — clear it
          localStorage.removeItem("stash-token");
          setToken(null);
          setAuthLoading(false);
          setIsLoading(false);
        }
      } else {
        // No token — just finish loading (will show login screen)
        setIsLoading(false);
      }
    };
    loadData();
  }, []);

  // Items are now saved via API calls (addItem, editItem, deleteItem, etc.)
  // No localStorage save needed for items.

  // Save settings
  useEffect(() => {
    if (!isLoading) {
      (async () => {
        try { await window.storage.set("stash-settings", JSON.stringify(settings)); }
        catch (e) { console.error("Settings save failed:", e); }
      })();
    }
  }, [settings, isLoading]);

  // Auto-archive: remove completed items older than threshold
  useEffect(() => {
    if (settings.autoArchiveDays > 0 && !isLoading) {
      const now = Date.now();
      const threshold = settings.autoArchiveDays * 24 * 60 * 60 * 1000;
      setItems(prev => prev.filter(item => {
        if (!item.completed || !item.completedAt) return true;
        return (now - new Date(item.completedAt).getTime()) < threshold;
      }));
    }
  }, [settings.autoArchiveDays, isLoading]);

  // Drag & drop
  const handleDragEnter = useCallback((e) => {
    e.preventDefault(); e.stopPropagation();
    dragCounterRef.current++;
    if (e.dataTransfer.types.includes("Files")) setIsDragging(true);
  }, []);
  const handleDragLeave = useCallback((e) => {
    e.preventDefault(); e.stopPropagation();
    dragCounterRef.current--;
    if (dragCounterRef.current === 0) setIsDragging(false);
  }, []);
  const handleDragOver = useCallback((e) => { e.preventDefault(); e.stopPropagation(); }, []);
  const handleDrop = useCallback(async (e) => {
    e.preventDefault(); e.stopPropagation();
    setIsDragging(false); dragCounterRef.current = 0;
    const files = Array.from(e.dataTransfer.files);
    const imageFile = files.find(f => f.type.startsWith("image/"));
    if (imageFile) {
      try {
        const base64 = await readFileAsBase64(imageFile);
        const compressed = await compressImage(base64);
        setPendingImage({ data: compressed, fileName: imageFile.name });
        inputRef.current?.focus();
      } catch (err) { console.error("Image read failed:", err); }
    }
  }, []);

  const addItem = () => {
    const text = inputValue.trim();
    if (!text && !pendingImage) return;
    const tags = [];
    const tagMatches = (text || "").match(/#(\w+)/g);
    if (tagMatches) tagMatches.forEach(t => tags.push(t.slice(1).toLowerCase()));
    const cleanContent = text ? text.replace(/#\w+/g, "").trim() : "";

    // Determine type: manual override > photo > auto-detect
    let itemType;
    if (pendingImage && selectedType === "auto") {
      itemType = "photo";
    } else if (selectedType !== "auto") {
      itemType = selectedType;
    } else {
      itemType = detectType(cleanContent || text, settings.customCategories);
    }

    // Generate a unique ID up front so we can reference this item
    // later when the OCR results come back asynchronously
    const newId = generateId();

    // Capture the image data before we clear pendingImage below
    const imageData = pendingImage ? pendingImage.data : null;

    setItems(prev => [{
      id: newId,
      content: cleanContent || (pendingImage ? pendingImage.fileName : text),
      type: itemType,
      tags: pendingImage && tags.length === 0 ? ["photo"] : tags,
      image: imageData,
      createdAt: new Date().toISOString(),
      completed: false,
      completedAt: null,
      pinned: false,
    }, ...prev]);
    // Sync to server
    apiFetch("/api/stashes", {
      method: "POST",
      body: JSON.stringify({
        id: newId,
        type: itemType,
        content: cleanContent || (pendingImage ? pendingImage.fileName : text),
        tags: pendingImage && tags.length === 0 ? ["photo"] : tags,
        image: imageData,
        createdAt: new Date().toISOString(),
      }),
    }).catch(err => console.error("[Sync] Create failed:", err.message));
    setInputValue("");
    setPendingImage(null);
    setSelectedType("auto"); // Reset to auto after stashing
    inputRef.current?.focus();

    // AUTO-SCAN: If this item has an image, automatically run OCR
    // in the background. The card appears immediately with the photo,
    // and we update it in place when results come back.
    if (imageData) {
      setScanningId(newId);
      extractBusinessCard(imageData).then((cardData) => {
        setScanningId(null);
        if (cardData) {
          // OCR found contact info — update the item
          const formatted = formatCardInfo(cardData);
          const updatedTags = [...tags];
          if (!updatedTags.includes("business-card")) updatedTags.push("business-card");
          if (cardData.company && !updatedTags.includes(cardData.company.toLowerCase())) {
            updatedTags.push(cardData.company.toLowerCase().replace(/\s+/g, "-"));
          }
          // setItems uses a callback so we always work with the
          // latest state — this avoids overwriting any edits the
          // user made while OCR was running
          setItems(prev => prev.map(item =>
            item.id === newId
              ? { ...item, content: formatted, type: "contact", tags: updatedTags, ocrData: cardData }
              : item
          ));
          // Sync OCR results to server
          apiFetch(`/api/stashes/${newId}`, {
            method: "PUT",
            body: JSON.stringify({
              content: formatted,
              type: "contact",
              tags: updatedTags,
              ocrData: cardData,
            }),
          }).catch(err => console.error("[Sync] OCR update failed:", err.message));
        }
        // If cardData is null, the image wasn't a business card —
        // we just leave the item as a regular photo. No harm done.
      });
    }
  };

  const deleteItem = (id) => {
    const item = items.find(i => i.id === id);
    // Trigger slide-out animation
    setSlidingOut(prev => new Set(prev).add(id));
    setTimeout(() => {
      setSlidingOut(prev => { const next = new Set(prev); next.delete(id); return next; });
      setItems(prev => prev.filter(i => i.id !== id));
      // Sync to server
      apiFetch(`/api/stashes/${id}`, { method: "DELETE" })
        .catch(err => console.error("[Sync] Delete failed:", err.message));

      // Set up undo
      if (item) {
        setUndoItem({ items: [item], label: "Deleted" });
        if (undoTimer) clearTimeout(undoTimer);
        const timer = setTimeout(() => { setUndoItem(null); }, 5000);
        setUndoTimer(timer);
      }
    }, 300); // match animation duration
  };

  const deleteMultiple = (ids) => {
    const deletedItems = items.filter(i => ids.has(i.id));
    // Trigger slide-out for all
    setSlidingOut(prev => { const next = new Set(prev); ids.forEach(id => next.add(id)); return next; });
    setTimeout(() => {
      setSlidingOut(new Set());
      setItems(prev => prev.filter(i => !ids.has(i.id)));
      // Sync to server
      ids.forEach(id => {
        apiFetch(`/api/stashes/${id}`, { method: "DELETE" })
          .catch(err => console.error("[Sync] Delete failed:", err.message));
      });
      setBulkSelected(new Set());
      setBulkMode(false);

      if (deletedItems.length > 0) {
        setUndoItem({ items: deletedItems, label: `Deleted ${deletedItems.length} items` });
        if (undoTimer) clearTimeout(undoTimer);
        const timer = setTimeout(() => { setUndoItem(null); }, 5000);
        setUndoTimer(timer);
      }
    }, 300);
  };

  const completeMultiple = (ids) => {
    const completedAt = new Date().toISOString();
    setItems(prev => prev.map(item =>
      ids.has(item.id) ? { ...item, completed: true, completedAt } : item
    ));
    // Sync to server
    ids.forEach(id => {
      apiFetch(`/api/stashes/${id}`, {
        method: "PUT",
        body: JSON.stringify({ completed: true, completedAt }),
      }).catch(err => console.error("[Sync] Update failed:", err.message));
    });
    setBulkSelected(new Set());
    setBulkMode(false);
  };

  const restoreItem = () => {
    if (undoItem) {
      setItems(prev => [...undoItem.items, ...prev]);
      // Re-create on server (items were already deleted by the sync call)
      undoItem.items.forEach(item => {
        apiFetch("/api/stashes", {
          method: "POST",
          body: JSON.stringify(item),
        }).catch(err => console.error("[Sync] Restore failed:", err.message));
      });
      setUndoItem(null);
      if (undoTimer) clearTimeout(undoTimer);
    }
  };

  const toggleBulkSelect = (id) => {
    setBulkSelected(prev => {
      const next = new Set(prev);
      if (next.has(id)) next.delete(id); else next.add(id);
      return next;
    });
  };

  const clearAllCompleted = () => {
    const completedIds = items.filter(i => i.completed).map(i => i.id);
    const deletedItems = items.filter(i => i.completed);
    
    setSlidingOut(prev => { const next = new Set(prev); completedIds.forEach(id => next.add(id)); return next; });
    setTimeout(() => {
      setSlidingOut(new Set());
      setItems(prev => prev.filter(i => !i.completed));
      // Sync to server
      completedIds.forEach(id => {
        apiFetch(`/api/stashes/${id}`, { method: "DELETE" })
          .catch(err => console.error("[Sync] Delete failed:", err.message));
      });
      setConfirmClearAll(false);

      if (deletedItems.length > 0) {
        setUndoItem({ items: deletedItems, label: `Cleared ${deletedItems.length} completed` });
        if (undoTimer) clearTimeout(undoTimer);
        const timer = setTimeout(() => { setUndoItem(null); }, 5000);
        setUndoTimer(timer);
      }
    }, 300);
  };

  const toggleComplete = (id) => {
    const item = items.find(i => i.id === id);
    if (!item) return;
    const completed = !item.completed;
    const completedAt = completed ? new Date().toISOString() : null;

    setItems(prev => prev.map(i =>
      i.id === id ? { ...i, completed, completedAt } : i
    ));
    // Sync to server
    apiFetch(`/api/stashes/${id}`, {
      method: "PUT",
      body: JSON.stringify({ completed, completedAt }),
    }).catch(err => console.error("[Sync] Update failed:", err.message));
  };

  // Edit an item's content, tags, and re-detect its type
  const editItem = (id, updates) => {
    setItems(prev => prev.map(item =>
      item.id === id
        ? { ...item, ...updates }
        : item
    ));
    // Sync to server
    apiFetch(`/api/stashes/${id}`, {
      method: "PUT",
      body: JSON.stringify(updates),
    }).catch(err => console.error("[Sync] Update failed:", err.message));
  };

  // Scan business card with OCR
  const [scanningId, setScanningId] = useState(null);
  const scanBusinessCard = async (id) => {
    const item = items.find(i => i.id === id);
    if (!item?.image) return;

    setScanningId(id);
    const cardData = await extractBusinessCard(item.image);
    setScanningId(null);

    if (cardData) {
      const formatted = formatCardInfo(cardData);
      const newTags = [...(item.tags || [])];
      if (!newTags.includes("business-card")) newTags.push("business-card");
      if (cardData.company && !newTags.includes(cardData.company.toLowerCase())) {
        newTags.push(cardData.company.toLowerCase().replace(/\s+/g, "-"));
      }

      editItem(id, {
        content: formatted,
        type: "contact",
        tags: newTags,
        ocrData: cardData,
      });
    }
  };

  // Toggle pin status
  const togglePin = (id) => {
    const item = items.find(i => i.id === id);
    if (!item) return;
    const pinned = !item.pinned;

    setItems(prev => prev.map(i =>
      i.id === id ? { ...i, pinned } : i
    ));
    // Sync to server
    apiFetch(`/api/stashes/${id}`, {
      method: "PUT",
      body: JSON.stringify({ pinned }),
    }).catch(err => console.error("[Sync] Update failed:", err.message));
  };

  const handleKeyDown = (e) => {
    if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); addItem(); }
    if (e.key === "Escape" && pendingImage) setPendingImage(null);
  };

  const handleFileSelect = async (e) => {
    const file = e.target.files?.[0];
    if (file?.type.startsWith("image/")) {
      try {
        const base64 = await readFileAsBase64(file);
        const compressed = await compressImage(base64);
        setPendingImage({ data: compressed, fileName: file.name });
        inputRef.current?.focus();
      } catch (err) { console.error("Image read failed:", err); }
    }
    e.target.value = "";
  };

  // Filtering (respects showCompleted setting)
  // BUGFIX: When searching with "#cooking", we strip the "#" so it
  // matches the stored tag "cooking". We also check if the raw query
  // (with #) appears in the content, in case someone literally typed
  // "#cooking" in their note text.
  const filteredItems = items.filter(item => {
    if (item.completed && !settings.showCompleted) return false;
    const raw = searchQuery.toLowerCase();
    const stripped = raw.replace(/^#/, "");
    const matchesSearch = !searchQuery ||
      (item.content || "").toLowerCase().includes(raw) ||
      (item.tags || []).some(t => t.includes(stripped));
    const matchesType = filterType === "all" || item.type === filterType;
    return matchesSearch && matchesType;
  }).sort((a, b) => {
    // Pinned items float to top within their group
    if (a.pinned && !b.pinned) return -1;
    if (!a.pinned && b.pinned) return 1;
    // Then sort by date
    const dateA = new Date(a.createdAt).getTime();
    const dateB = new Date(b.createdAt).getTime();
    return sortOrder === "oldest" ? dateA - dateB : dateB - dateA;
  });

  // Date grouping helper
  const getDateGroup = (dateStr) => {
    const d = new Date(dateStr);
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const yesterday = new Date(today); yesterday.setDate(today.getDate() - 1);
    const weekAgo = new Date(today); weekAgo.setDate(today.getDate() - 7);
    const monthAgo = new Date(today); monthAgo.setMonth(today.getMonth() - 1);
    
    if (d >= today) return "Today";
    if (d >= yesterday) return "Yesterday";
    if (d >= weekAgo) return "This week";
    if (d >= monthAgo) return "This month";
    // Older — show month + year
    return d.toLocaleDateString("en-US", { month: "long", year: "numeric" });
  };

  // Group items by date for rendering
  const groupItemsByDate = (itemsList) => {
    const groups = [];
    let currentGroup = null;
    itemsList.forEach(item => {
      const group = getDateGroup(item.createdAt);
      if (!currentGroup || currentGroup.label !== group) {
        currentGroup = { label: group, items: [] };
        groups.push(currentGroup);
      }
      currentGroup.items.push(item);
    });
    return groups;
  };

  const activeItems = items.filter(i => !i.completed);
  const completedItems = items.filter(i => i.completed);
  const typeCounts = items.filter(i => settings.showCompleted || !i.completed).reduce((acc, item) => {
    acc[item.type] = (acc[item.type] || 0) + 1;
    return acc;
  }, {});

  const hasContent = inputValue.trim() || pendingImage;

  if (isLoading) {
    return (
      <div style={{
        minHeight: "100vh", background: theme.pageBg,
        display: "flex", alignItems: "center", justifyContent: "center",
        color: theme.textFaint, fontFamily: "'Lora', serif",
        fontStyle: "italic", fontSize: "15px",
        transition: "background 0.4s ease",
      }}>opening your stash…</div>
    );
  }

  return (
    <div
      onDragEnter={handleDragEnter}
      onDragLeave={handleDragLeave}
      onDragOver={handleDragOver}
      onDrop={handleDrop}
      style={{
        minHeight: "100vh",
        background: theme.pageBg,
        color: theme.textPrimary,
        fontFamily: "'DM Sans', sans-serif",
        position: "relative",
        transition: "background 0.4s ease, color 0.4s ease",
      }}
    >
      <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,500;0,600;1,400;1,500&family=DM+Sans:ital,wght@0,300;0,400;0,500;1,300;1,400&display=swap" rel="stylesheet" />
      <style>{`
        @keyframes cardIn {
          from { opacity: 0; transform: translateY(6px); }
          to { opacity: 1; transform: translateY(0); }
        }
        @keyframes softFadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        @keyframes gentlePulse {
          0%, 100% { opacity: 0.5; transform: scale(1); }
          50% { opacity: 0.8; transform: scale(1.02); }
        }
        @keyframes dropIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        @keyframes settingsIn {
          from { opacity: 0; transform: scale(0.96) translateY(8px); }
          to { opacity: 1; transform: scale(1) translateY(0); }
        }
        @keyframes toastIn {
          from { opacity: 0; transform: translateY(16px); }
          to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideOut {
          from { opacity: 1; transform: translateX(0); max-height: 300px; margin-bottom: 8px; }
          to { opacity: 0; transform: translateX(80px); max-height: 0; margin-bottom: 0; overflow: hidden; }
        }
        * { box-sizing: border-box; }
        ::placeholder { color: ${theme.textFaint}; }
        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: ${theme.border}; border-radius: 10px; }
        textarea:focus, input:focus { outline: none; }
        body { margin: 0; }
        select option { background: ${theme.cardBg}; color: ${theme.textPrimary}; }
        .category-scroll::-webkit-scrollbar { display: none; }
        .category-scroll { -ms-overflow-style: none; scrollbar-width: none; }
      `}</style>

      {/* Drop zone */}
      {isDragging && (
        <div style={{
          position: "fixed", inset: 0, background: theme.overlayBg,
          backdropFilter: "blur(20px)", zIndex: 999,
          display: "flex", alignItems: "center", justifyContent: "center",
          animation: "dropIn 0.25s ease",
        }}>
          <div style={{
            border: `2px dashed ${theme.borderHover}`,
            borderRadius: "28px", padding: "64px 80px", textAlign: "center",
            animation: "gentlePulse 2.5s ease infinite",
          }}>
            <div style={{
              width: "72px", height: "72px", borderRadius: "50%",
              background: theme.hoverBg, margin: "0 auto 20px",
              display: "flex", alignItems: "center", justifyContent: "center",
              fontSize: "28px", color: theme.textMuted,
            }}>▫</div>
            <p style={{
              fontFamily: "'Lora', serif", fontSize: "24px",
              color: theme.textSecondary, margin: "0 0 8px",
            }}>Drop it right here</p>
            <p style={{
              fontFamily: "'DM Sans', sans-serif", fontSize: "14px", color: theme.textFaint,
            }}>photos, screenshots, business cards — all welcome</p>
          </div>
        </div>
      )}

      {viewingImage && <ImageViewer src={viewingImage} onClose={() => setViewingImage(null)} theme={theme} />}

      <SettingsPanel
        isOpen={settingsOpen}
        onClose={() => setSettingsOpen(false)}
        settings={settings}
        onUpdateSettings={setSettings}
        theme={theme}
        itemCount={activeItems.length}
        completedCount={completedItems.length}
        onExport={() => exportData(items, settings)}
        onExportFull={() => exportDataFull(items, settings)}
        onImport={(data) => {
          if (data?.items && Array.isArray(data.items)) {
            // Merge or replace — we'll replace for simplicity
            setItems(data.items);
            if (data.settings) setSettings(prev => ({ ...prev, ...data.settings }));
            setSettingsOpen(false);
          } else {
            alert("This doesn't look like a valid Stash backup file.");
          }
        }}
      />

      {/* ===== MAIN CONTENT ===== */}
      <div style={{
        maxWidth: "580px", margin: "0 auto", padding: "40px 20px",
        animation: "softFadeIn 0.6s ease",
      }}>
        {/* Header */}
        <header style={{
          marginBottom: "36px",
          display: "flex", alignItems: "baseline", justifyContent: "space-between",
        }}>
          <div>
            <h1 style={{
              fontFamily: "'Lora', serif", fontSize: "32px", fontWeight: 400,
              margin: "0 0 2px", color: theme.textSecondary,
              letterSpacing: "-0.02em",
            }}>Stash</h1>
            <p style={{
              fontFamily: "'Lora', serif", fontSize: "13.5px",
              color: theme.textGhost, margin: 0, fontStyle: "italic",
            }}>the things worth holding onto</p>
          </div>
          <button
            onClick={() => setSettingsOpen(true)}
            style={{
              background: theme.hoverBg, border: `1px solid ${theme.border}`,
              color: theme.textMuted, cursor: "pointer",
              fontSize: "13px", padding: "7px 14px",
              borderRadius: "10px", transition: "all 0.25s ease",
              fontFamily: "'DM Sans', sans-serif",
            }}
            onMouseEnter={e => {
              e.currentTarget.style.color = theme.textSecondary;
              e.currentTarget.style.borderColor = theme.borderHover;
            }}
            onMouseLeave={e => {
              e.currentTarget.style.color = theme.textMuted;
              e.currentTarget.style.borderColor = theme.border;
            }}
          >Settings</button>
        </header>

        {/* Capture input */}
        <div style={{
          background: theme.inputBg, borderRadius: "16px",
          border: `1px solid ${pendingImage ? theme.borderHover : theme.border}`,
          padding: "4px", marginBottom: "28px",
          transition: "all 0.35s ease", boxShadow: theme.shadowMedium,
        }}>
          {pendingImage && (
            <div style={{ margin: "14px 14px 6px", position: "relative", display: "inline-block" }}>
              <img src={pendingImage.data} alt="Pending" style={{
                maxHeight: "110px", maxWidth: "180px",
                borderRadius: "12px", border: `1px solid ${theme.border}`, display: "block",
              }} />
              <button onClick={() => setPendingImage(null)} style={{
                position: "absolute", top: "-7px", right: "-7px",
                width: "22px", height: "22px", borderRadius: "50%",
                background: theme.deleteColor, border: `2px solid ${theme.inputBg}`,
                color: "#fff", fontSize: "11px", cursor: "pointer",
                display: "flex", alignItems: "center", justifyContent: "center",
                lineHeight: 1, padding: 0,
              }}>×</button>
              <div style={{
                marginTop: "5px", fontSize: "11px", color: theme.textMuted,
                fontFamily: "'DM Sans', sans-serif", fontStyle: "italic",
              }}>{pendingImage.fileName}</div>
            </div>
          )}

          <div style={{ display: "flex", alignItems: "flex-end", gap: "4px" }}>
            <textarea
              ref={inputRef}
              value={inputValue}
              onChange={e => setInputValue(e.target.value)}
              onKeyDown={handleKeyDown}
              placeholder={pendingImage ? "Add a note about this photo…" : "What would you like to remember?"}
              rows={1}
              style={{
                flex: 1, background: "none", border: "none",
                color: theme.textPrimary, fontSize: "15.5px",
                fontFamily: "'Lora', serif",
                padding: "16px 18px", resize: "none", lineHeight: "1.6",
              }}
              onInput={e => {
                e.target.style.height = "auto";
                e.target.style.height = Math.min(e.target.scrollHeight, 120) + "px";
              }}
            />
            <button
              onClick={addItem}
              disabled={!hasContent}
              style={{
                background: hasContent ? theme.accent : theme.disabledBg,
                border: "none",
                color: hasContent ? "#FAF7F2" : theme.disabledText,
                borderRadius: "12px", padding: "10px 20px",
                fontSize: "14px", fontFamily: "'DM Sans', sans-serif",
                fontWeight: 500,
                cursor: hasContent ? "pointer" : "default",
                transition: "all 0.3s ease", margin: "6px", whiteSpace: "nowrap",
                opacity: hasContent ? 1 : 0.7,
              }}
            >Stash</button>
          </div>

          {/* Category selector — horizontal swipeable strip */}
          <div style={{
            padding: "6px 6px 4px",
            position: "relative",
          }}>
            <div
              className="category-scroll"
              style={{
                display: "flex", alignItems: "center", gap: "2px",
                overflowX: "auto",
                scrollBehavior: "smooth",
                WebkitOverflowScrolling: "touch",
                msOverflowStyle: "none",
                scrollbarWidth: "none",
                padding: "2px 10px",
                maskImage: "linear-gradient(to right, transparent 0px, black 12px, black calc(100% - 12px), transparent 100%)",
                WebkitMaskImage: "linear-gradient(to right, transparent 0px, black 12px, black calc(100% - 12px), transparent 100%)",
              }}
            >
              <button
                onClick={() => setSelectedType("auto")}
                style={{
                  background: selectedType === "auto" ? theme.hoverBg : "transparent",
                  border: selectedType === "auto" ? `1px solid ${theme.border}` : "1px solid transparent",
                  color: selectedType === "auto" ? theme.textSecondary : theme.textGhost,
                  borderRadius: "20px", padding: "5px 14px", fontSize: "12px",
                  fontFamily: "'DM Sans', sans-serif", cursor: "pointer",
                  transition: "all 0.2s ease", fontStyle: "italic",
                  whiteSpace: "nowrap", flexShrink: 0,
                }}
              >Auto</button>
              {getAllTypes(settings.customCategories).map(type => {
                const info = getTypeInfo(type, settings.customCategories);
                const colors = getTypeColors(type, theme, settings.customCategories);
                const isActive = selectedType === type;
                return (
                  <button
                    key={type}
                    onClick={() => setSelectedType(isActive ? "auto" : type)}
                    style={{
                      background: isActive ? colors.bg : "transparent",
                      border: isActive ? `1px solid ${colors.color}44` : "1px solid transparent",
                      color: isActive ? colors.color : theme.textGhost,
                      borderRadius: "20px", padding: "5px 14px", fontSize: "12px",
                      fontFamily: "'DM Sans', sans-serif", cursor: "pointer",
                      transition: "all 0.2s ease",
                      whiteSpace: "nowrap", flexShrink: 0,
                    }}
                    onMouseEnter={e => { if (!isActive) e.currentTarget.style.color = colors.color; }}
                    onMouseLeave={e => { if (!isActive) e.currentTarget.style.color = theme.textGhost; }}
                  >{info.label}</button>
                );
              })}
            </div>
          </div>

          {/* Bottom bar — hints + photo */}
          <div style={{
            padding: "2px 18px 12px",
            display: "flex", alignItems: "center", justifyContent: "space-between",
          }}>
            <span style={{
              fontSize: "12px", color: theme.textGhost,
              fontFamily: "'DM Sans', sans-serif", fontStyle: "italic",
            }}>enter to save · #tags to organize</span>
            <label style={{
              display: "flex", alignItems: "center", gap: "5px",
              fontSize: "12px", color: theme.textFaint,
              fontFamily: "'DM Sans', sans-serif",
              cursor: "pointer", padding: "5px 12px",
              borderRadius: "10px", transition: "all 0.25s ease",
            }}
            onMouseEnter={e => { e.currentTarget.style.background = theme.hoverBg; e.currentTarget.style.color = theme.textSecondary; }}
            onMouseLeave={e => { e.currentTarget.style.background = "transparent"; e.currentTarget.style.color = theme.textFaint; }}
            >
              Upload photo
              <input type="file" accept="image/*" onChange={handleFileSelect} style={{ display: "none" }} />
            </label>
          </div>
        </div>

        {/* Search + filters */}
        {items.length > 0 && (
          <div style={{ marginBottom: "20px" }}>
            <div style={{
              background: theme.searchBg, borderRadius: "12px",
              border: `1px solid ${theme.border}`,
              padding: "10px 16px", marginBottom: "10px",
              display: "flex", alignItems: "center", gap: "10px",
            }}>
              <span style={{ color: theme.textGhost, fontSize: "14px", fontFamily: "'DM Sans', sans-serif" }}>⌕</span>
              <input
                type="text" value={searchQuery}
                onChange={e => setSearchQuery(e.target.value)}
                placeholder="Search your memories…"
                style={{
                  flex: 1, background: "none", border: "none",
                  color: theme.textPrimary, fontSize: "14px",
                  fontFamily: "'Lora', serif", fontStyle: "italic",
                }}
              />
              {searchQuery && (
                <button onClick={() => setSearchQuery("")} style={{
                  background: "none", border: "none",
                  color: theme.textFaint, cursor: "pointer", fontSize: "14px", padding: "2px 6px",
                }}>×</button>
              )}
            </div>
            <div style={{ display: "flex", gap: "6px", flexWrap: "wrap" }}>
              <button onClick={() => setFilterType("all")} style={{
                background: filterType === "all" ? theme.cardBg : "transparent",
                border: filterType === "all" ? `1px solid ${theme.border}` : "1px solid transparent",
                boxShadow: filterType === "all" ? theme.shadowLight : "none",
                color: filterType === "all" ? theme.textSecondary : theme.textGhost,
                borderRadius: "20px", padding: "4px 12px", fontSize: "12px",
                fontFamily: "'DM Sans', sans-serif", cursor: "pointer", transition: "all 0.25s ease",
              }}>All {items.filter(i => settings.showCompleted || !i.completed).length}</button>
              {Object.entries(typeCounts).map(([type, count]) => {
                const colors = getTypeColors(type, theme, settings.customCategories);
                const labels = getTypeInfo(type, settings.customCategories);
                const isActive = filterType === type;
                return (
                  <button key={type}
                    onClick={() => setFilterType(isActive ? "all" : type)}
                    style={{
                      background: isActive ? colors.bg : "transparent",
                      border: isActive ? `1px solid ${colors.color}33` : "1px solid transparent",
                      color: isActive ? colors.color : theme.textGhost,
                      borderRadius: "20px", padding: "4px 12px", fontSize: "12px",
                      fontFamily: "'DM Sans', sans-serif", cursor: "pointer", transition: "all 0.25s ease",
                    }}
                  >{labels.label} {count}</button>
                );
              })}
            </div>
            {/* Sort toggle + Bulk mode */}
            <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginTop: "8px" }}>
              <button
                onClick={() => { setBulkMode(prev => !prev); setBulkSelected(new Set()); }}
                style={{
                  background: bulkMode ? theme.accent + "18" : "none",
                  border: bulkMode ? `1px solid ${theme.accent}33` : "1px solid transparent",
                  cursor: "pointer",
                  color: bulkMode ? theme.accent : theme.textMuted,
                  fontSize: "12px",
                  fontFamily: "'DM Sans', sans-serif",
                  padding: "3px 10px", borderRadius: "8px",
                  transition: "all 0.2s ease",
                }}
              >
                {bulkMode ? `${bulkSelected.size} selected` : "Select"}
              </button>
              <button
                onClick={() => setSortOrder(prev => prev === "newest" ? "oldest" : "newest")}
                style={{
                  background: "none", border: "none", cursor: "pointer",
                  color: theme.textMuted, fontSize: "12px",
                  fontFamily: "'DM Sans', sans-serif",
                  padding: "2px 4px", transition: "color 0.2s ease",
                  display: "flex", alignItems: "center", gap: "4px",
                }}
              >
                <span style={{ fontSize: "10px" }}>{sortOrder === "newest" ? "↓" : "↑"}</span>
                {sortOrder === "newest" ? "Newest first" : "Oldest first"}
              </button>
            </div>

            {/* Bulk action bar */}
            {bulkMode && bulkSelected.size > 0 && (
              <div style={{
                display: "flex", gap: "8px", marginTop: "10px",
                animation: "softFadeIn 0.2s ease forwards",
              }}>
                <button
                  onClick={() => completeMultiple(bulkSelected)}
                  style={{
                    background: theme.checkBg, border: `1px solid ${theme.checkColor}44`,
                    color: theme.checkColor, cursor: "pointer",
                    fontSize: "12px", fontFamily: "'DM Sans', sans-serif", fontWeight: 500,
                    padding: "5px 14px", borderRadius: "8px", transition: "all 0.2s ease",
                  }}
                >Complete {bulkSelected.size}</button>
                <button
                  onClick={() => deleteMultiple(bulkSelected)}
                  style={{
                    background: theme.deleteBg, border: `1px solid ${theme.deleteColor}44`,
                    color: theme.deleteColor, cursor: "pointer",
                    fontSize: "12px", fontFamily: "'DM Sans', sans-serif", fontWeight: 500,
                    padding: "5px 14px", borderRadius: "8px", transition: "all 0.2s ease",
                  }}
                >Delete {bulkSelected.size}</button>
              </div>
            )}
          </div>
        )}

        {/* ============================================================
            ITEMS — now split into Active and Completed sections
            
            NEW CONCEPT: "List partitioning"
            Instead of one flat list, we split filtered items into two
            groups and render them separately. This is a very common
            pattern — think of email (inbox vs archive), or a kanban
            board (to-do vs done). Same data, different views.
            ============================================================ */}
        {(() => {
          const activeFiltered = filteredItems.filter(i => !i.completed);
          const completedFiltered = filteredItems.filter(i => i.completed);
          const hasAny = items.length > 0;
          const hasResults = activeFiltered.length > 0 || completedFiltered.length > 0;

          if (!hasAny) return <EmptyState theme={theme} />;
          if (!hasResults) {
            const emptyHints = {
              link: "Paste a URL to save it here",
              contact: "Scan a business card or add contact info",
              travel: "Save flight details, hotel bookings, or trip ideas",
              work: "Stash meeting notes, deadlines, or project ideas",
              money: "Track expenses, invoices, or financial notes",
              health: "Log appointments, prescriptions, or wellness notes",
              media: "Save movie recs, podcast links, or playlist ideas",
              event: "Remember dates, parties, or upcoming plans",
              reading: "Bookmark articles, books, or things to read later",
              food: "Save recipes, restaurant names, or meal plans",
              idea: "Jot down a thought — you never know where it'll lead",
              person: "Remember someone's name, details, or context",
              photo: "Drop a photo to get started",
              note: "Type anything — it all belongs here",
            };
            const hint = filterType !== "all" && emptyHints[filterType]
              ? emptyHints[filterType]
              : `nothing matches "${searchQuery || filterType}"`;
            return (
              <div style={{ textAlign: "center", padding: "48px 24px" }}>
                <p style={{
                  fontFamily: "'Lora', serif", fontSize: "15px",
                  color: theme.textFaint, fontStyle: "italic",
                  margin: "0 0 6px",
                }}>
                  {filterType !== "all" && !searchQuery
                    ? `No ${filterType}s yet`
                    : `Nothing found`
                  }
                </p>
                <p style={{
                  fontFamily: "'DM Sans', sans-serif", fontSize: "13px",
                  color: theme.textGhost, margin: 0,
                }}>{hint}</p>
              </div>
            );
          }

          return (
            <div>
              {/* Active items — grouped by date */}
              {activeFiltered.length > 0 && (
                <div>
                  {groupItemsByDate(activeFiltered).map(group => (
                    <div key={group.label}>
                      <div style={{
                        padding: "4px 4px 8px",
                        fontFamily: "'DM Sans', sans-serif",
                        fontSize: "11.5px", fontWeight: 500,
                        color: theme.textGhost,
                        letterSpacing: "0.5px",
                        textTransform: "uppercase",
                        marginTop: "16px",
                      }}>
                        {group.label}
                        <span style={{ marginLeft: "6px", fontWeight: 400, opacity: 0.6 }}>
                          · {group.items.length}
                        </span>
                      </div>
                      {group.items.map(item => (
                        <StashCard
                          key={item.id} item={item}
                          onDelete={deleteItem}
                          onToggleComplete={toggleComplete}
                          onEdit={editItem}
                          onTogglePin={togglePin}
                          onScanCard={scanBusinessCard}
                          isScanning={scanningId === item.id}
                          onViewImage={src => setViewingImage(src)}
                          theme={theme}
                          timezone={settings.timezone}
                          customCategories={settings.customCategories}
                          isSlidingOut={slidingOut.has(item.id)}
                          bulkMode={bulkMode}
                          isSelected={bulkSelected.has(item.id)}
                          onToggleBulkSelect={toggleBulkSelect}
                        />
                      ))}
                    </div>
                  ))}
                </div>
              )}

              {/* Empty active state — everything is done! */}
              {activeFiltered.length === 0 && completedFiltered.length > 0 && !searchQuery && (
                <div style={{
                  textAlign: "center", padding: "40px 24px 24px",
                }}>
                  <div style={{
                    width: "48px", height: "48px", borderRadius: "50%",
                    background: theme.checkBg, margin: "0 auto 14px",
                    display: "flex", alignItems: "center", justifyContent: "center",
                    fontSize: "20px", color: theme.checkColor,
                    border: `1px solid ${theme.checkColor}33`,
                  }}>✓</div>
                  <p style={{
                    fontFamily: "'Lora', serif", fontSize: "17px",
                    color: theme.textSecondary, margin: "0 0 4px",
                  }}>All caught up</p>
                  <p style={{
                    fontFamily: "'DM Sans', sans-serif", fontSize: "13px",
                    color: theme.textFaint, fontStyle: "italic", margin: 0,
                  }}>Everything's been handled — nice work</p>
                </div>
              )}

              {/* Completed section */}
              {completedFiltered.length > 0 && settings.showCompleted && (
                <div style={{ marginTop: activeFiltered.length > 0 ? "28px" : "8px" }}>
                  {/* Section header with toggle and clear button */}
                  <div style={{
                    display: "flex", alignItems: "center", justifyContent: "space-between",
                    marginBottom: "14px", padding: "0 4px",
                  }}>
                    <button
                      onClick={() => setCompletedExpanded(prev => !prev)}
                      style={{
                        background: "none", border: "none", cursor: "pointer",
                        display: "flex", alignItems: "center", gap: "8px",
                        padding: "4px 0",
                      }}
                    >
                      {/* Expand/collapse chevron */}
                      <span style={{
                        fontSize: "11px", color: theme.textGhost,
                        transition: "transform 0.3s ease",
                        transform: completedExpanded ? "rotate(90deg)" : "rotate(0deg)",
                        display: "inline-block",
                      }}>▸</span>
                      <span style={{
                        fontFamily: "'DM Sans', sans-serif", fontSize: "13px",
                        color: theme.textMuted, fontWeight: 500,
                        letterSpacing: "0.03em",
                      }}>
                        Completed
                      </span>
                      <span style={{
                        fontFamily: "'DM Sans', sans-serif", fontSize: "12px",
                        color: theme.textGhost, fontStyle: "italic",
                      }}>
                        {completedFiltered.length}
                      </span>
                    </button>

                    {/* Clear all completed — with confirmation */}
                    {confirmClearAll ? (
                      <div style={{ display: "flex", alignItems: "center", gap: "6px" }}>
                        <span style={{
                          fontSize: "12px", color: theme.deleteColor,
                          fontFamily: "'DM Sans', sans-serif",
                        }}>Clear {completedFiltered.length} items?</span>
                        <button
                          onClick={clearAllCompleted}
                          style={{
                            background: theme.deleteBg, border: `1px solid ${theme.deleteColor}44`,
                            color: theme.deleteColor, cursor: "pointer",
                            fontSize: "11px", fontFamily: "'DM Sans', sans-serif",
                            fontWeight: 500, padding: "3px 10px",
                            borderRadius: "6px", transition: "all 0.2s ease",
                          }}
                        >Yes</button>
                        <button
                          onClick={() => setConfirmClearAll(false)}
                          style={{
                            background: "none", border: `1px solid ${theme.border}`,
                            color: theme.textMuted, cursor: "pointer",
                            fontSize: "11px", fontFamily: "'DM Sans', sans-serif",
                            padding: "3px 10px",
                            borderRadius: "6px", transition: "all 0.2s ease",
                          }}
                        >No</button>
                      </div>
                    ) : (
                    <button
                      onClick={() => setConfirmClearAll(true)}
                      style={{
                        background: "none", border: "none",
                        color: theme.textGhost, cursor: "pointer",
                        fontSize: "12px", fontFamily: "'DM Sans', sans-serif",
                        fontStyle: "italic", padding: "4px 10px",
                        borderRadius: "8px", transition: "all 0.25s ease",
                      }}
                      onMouseEnter={e => {
                        e.currentTarget.style.color = theme.deleteColor;
                        e.currentTarget.style.background = theme.deleteBg;
                      }}
                      onMouseLeave={e => {
                        e.currentTarget.style.color = theme.textGhost;
                        e.currentTarget.style.background = "none";
                      }}
                    >clear all</button>
                    )}
                  </div>

                  {/* Divider line */}
                  <div style={{
                    height: "1px",
                    background: theme.border,
                    marginBottom: "14px",
                  }} />

                  {/* Completed items (collapsible) */}
                  {completedExpanded && (
                    <div style={{ animation: "cardIn 0.3s ease forwards" }}>
                      {completedFiltered.map(item => (
                        <StashCard
                          key={item.id} item={item}
                          onDelete={deleteItem}
                          onToggleComplete={toggleComplete}
                          onEdit={editItem}
                          onTogglePin={togglePin}
                          onScanCard={scanBusinessCard}
                          isScanning={scanningId === item.id}
                          onViewImage={src => setViewingImage(src)}
                          theme={theme}
                          timezone={settings.timezone}
                          customCategories={settings.customCategories}
                          isSlidingOut={slidingOut.has(item.id)}
                          bulkMode={bulkMode}
                          isSelected={bulkSelected.has(item.id)}
                          onToggleBulkSelect={toggleBulkSelect}
                        />
                      ))}
                    </div>
                  )}
                </div>
              )}
            </div>
          );
        })()}

        {/* Footer */}
        <div style={{
          marginTop: "40px", paddingTop: "20px",
          borderTop: `1px solid ${theme.border}`,
          display: "flex", justifyContent: "space-between", alignItems: "center",
        }}>
          <span style={{
            fontFamily: "'Lora', serif", fontStyle: "italic",
            fontSize: "12px", color: theme.textGhost,
          }}>
            {activeItems.length} {activeItems.length === 1 ? "memory" : "memories"} kept safe
            {completedItems.length > 0 && ` · ${completedItems.length} completed`}
          </span>
          {items.length > 0 && (
            <button
              onClick={() => exportData(items, settings)}
              style={{
                background: "none", border: "none",
                color: theme.textGhost, cursor: "pointer",
                fontSize: "12px", fontFamily: "'DM Sans', sans-serif",
                fontStyle: "italic", padding: "2px 0",
                transition: "color 0.2s ease",
              }}
              onMouseEnter={e => { e.currentTarget.style.color = theme.textMuted; }}
              onMouseLeave={e => { e.currentTarget.style.color = theme.textGhost; }}
            >Export</button>
          )}
        </div>
      </div>

      {/* PWA Install Banner */}
      {!undoItem && <InstallBanner theme={theme} />}

      {/* Undo delete toast */}
      {undoItem && (
        <div style={{
          position: "fixed", bottom: "24px", left: "50%", transform: "translateX(-50%)",
          background: theme.cardBg, border: `1px solid ${theme.border}`,
          borderRadius: "14px", padding: "10px 12px 10px 18px",
          boxShadow: theme.shadowMedium, zIndex: 1000,
          display: "flex", alignItems: "center", gap: "12px",
          animation: "toastIn 0.3s ease forwards",
          fontFamily: "'DM Sans', sans-serif",
        }}>
          <span style={{
            fontSize: "13px", color: theme.textSecondary,
          }}>
            {undoItem.label}
          </span>
          <button
            onClick={restoreItem}
            style={{
              background: theme.accent, border: "none",
              color: "#FAF7F2", borderRadius: "8px",
              padding: "5px 14px", fontSize: "12.5px",
              fontFamily: "'DM Sans', sans-serif", fontWeight: 500,
              cursor: "pointer", transition: "opacity 0.2s ease",
            }}
          >Undo</button>
        </div>
      )}
    </div>
  );
}

// ============================================================
// PWA INSTALL BANNER COMPONENT
// ============================================================
function InstallBanner({ theme }) {
  const [canInstall, setCanInstall] = useState(false);
  const [dismissed, setDismissed] = useState(false);

  useEffect(() => {
    const onInstallable = () => setCanInstall(true);
    const onInstalled = () => { setCanInstall(false); setDismissed(false); };
    window.addEventListener("pwa-installable", onInstallable);
    window.addEventListener("pwa-installed", onInstalled);
    // Check if already installable
    if (window.deferredPrompt) setCanInstall(true);
    return () => {
      window.removeEventListener("pwa-installable", onInstallable);
      window.removeEventListener("pwa-installed", onInstalled);
    };
  }, []);

  const handleInstall = async () => {
    if (!deferredPrompt) return;
    deferredPrompt.prompt();
    const result = await deferredPrompt.userChoice;
    if (result.outcome === "accepted") {
      console.log("[PWA] User accepted install");
    }
    deferredPrompt = null;
    setCanInstall(false);
  };

  // Don't show if installed, dismissed, or in standalone mode
  if (!canInstall || dismissed) return null;
  if (window.matchMedia("(display-mode: standalone)").matches) return null;

  return (
    <div style={{
      position: "fixed", bottom: "24px", left: "50%", transform: "translateX(-50%)",
      background: theme.cardBg, border: `1px solid ${theme.border}`,
      borderRadius: "16px", padding: "14px 18px",
      boxShadow: theme.shadowMedium, zIndex: 900,
      display: "flex", alignItems: "center", gap: "14px",
      maxWidth: "380px", width: "90%",
      animation: "toastIn 0.4s ease forwards",
      fontFamily: "'DM Sans', sans-serif",
    }}>
      <div style={{ flex: 1 }}>
        <div style={{ fontSize: "14px", fontWeight: 500, color: theme.textPrimary, marginBottom: "2px" }}>
          Install Stash
        </div>
        <div style={{ fontSize: "12px", color: theme.textMuted }}>
          Add to your home screen for quick access
        </div>
      </div>
      <button
        onClick={handleInstall}
        style={{
          background: theme.accent, border: "none",
          color: "#FAF7F2", borderRadius: "10px",
          padding: "8px 16px", fontSize: "13px",
          fontFamily: "'DM Sans', sans-serif", fontWeight: 500,
          cursor: "pointer", whiteSpace: "nowrap",
        }}
      >Install</button>
      <button
        onClick={() => setDismissed(true)}
        style={{
          background: "none", border: "none",
          color: theme.textGhost, fontSize: "18px",
          cursor: "pointer", padding: "0 4px", lineHeight: 1,
        }}
      >×</button>
    </div>
  );
}

// ============================================================
// APP WRAPPER — adds the install banner
// ============================================================
function App() {
  return (
    <div>
      <Stash />
    </div>
  );
}

// Mount the app
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
  </script>
</body>
</html>
